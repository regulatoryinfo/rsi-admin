{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { EventEmitter, Directive, Input, Output, HostListener, NgModule } from '@angular/core';\nimport { latLng, map, control, tileLayer } from 'leaflet';\n\nclass LeafletUtil {\n  static mapToArray(map) {\n    const toReturn = [];\n\n    for (const k in map) {\n      if (map.hasOwnProperty(k)) {\n        toReturn.push(map[k]);\n      }\n    }\n\n    return toReturn;\n  }\n\n  static handleEvent(zone, eventEmitter, event) {\n    // Don't want to emit if there are no observers\n    if (0 < eventEmitter.observers.length) {\n      zone.run(() => {\n        eventEmitter.emit(event);\n      });\n    }\n  }\n\n}\n\nlet LeafletDirective = /*#__PURE__*/(() => {\n  class LeafletDirective {\n    constructor(element, zone) {\n      this.element = element;\n      this.zone = zone;\n      this.DEFAULT_ZOOM = 1;\n      this.DEFAULT_CENTER = latLng(38.907192, -77.036871);\n      this.DEFAULT_FPZ_OPTIONS = {};\n      this.fitBoundsOptions = this.DEFAULT_FPZ_OPTIONS;\n      this.panOptions = this.DEFAULT_FPZ_OPTIONS;\n      this.zoomOptions = this.DEFAULT_FPZ_OPTIONS;\n      this.zoomPanOptions = this.DEFAULT_FPZ_OPTIONS; // Default configuration\n\n      this.options = {}; // Configure callback function for the map\n\n      this.mapReady = new EventEmitter();\n      this.zoomChange = new EventEmitter();\n      this.centerChange = new EventEmitter(); // Mouse Map Events\n\n      this.onClick = new EventEmitter();\n      this.onDoubleClick = new EventEmitter();\n      this.onMouseDown = new EventEmitter();\n      this.onMouseUp = new EventEmitter();\n      this.onMouseMove = new EventEmitter();\n      this.onMouseOver = new EventEmitter();\n      this.onMouseOut = new EventEmitter(); // Map Move Events\n\n      this.onMapMove = new EventEmitter();\n      this.onMapMoveStart = new EventEmitter();\n      this.onMapMoveEnd = new EventEmitter(); // Map Zoom Events\n\n      this.onMapZoom = new EventEmitter();\n      this.onMapZoomStart = new EventEmitter();\n      this.onMapZoomEnd = new EventEmitter(); // Nothing here\n    }\n\n    ngOnInit() {\n      // Create the map outside of angular so the various map events don't trigger change detection\n      this.zone.runOutsideAngular(() => {\n        // Create the map with some reasonable defaults\n        this.map = map(this.element.nativeElement, this.options);\n        this.addMapEventListeners();\n      }); // Only setView if there is a center/zoom\n\n      if (null != this.center && null != this.zoom) {\n        this.setView(this.center, this.zoom);\n      } // Set up all the initial settings\n\n\n      if (null != this.fitBounds) {\n        this.setFitBounds(this.fitBounds);\n      }\n\n      if (null != this.maxBounds) {\n        this.setMaxBounds(this.maxBounds);\n      }\n\n      if (null != this.minZoom) {\n        this.setMinZoom(this.minZoom);\n      }\n\n      if (null != this.maxZoom) {\n        this.setMaxZoom(this.maxZoom);\n      }\n\n      this.doResize(); // Fire map ready event\n\n      this.mapReady.emit(this.map);\n    }\n\n    ngOnChanges(changes) {\n      /*\n       * The following code is to address an issue with our (basic) implementation of\n       * zooming and panning. From our testing, it seems that a pan operation followed\n       * by a zoom operation in the same thread will interfere with eachother. The zoom\n       * operation interrupts/cancels the pan, resulting in a final center point that is\n       * inaccurate. The solution seems to be to either separate them with a timeout or\n        * to collapse them into a setView call.\n       */\n      // Zooming and Panning\n      if (changes['zoom'] && changes['center'] && null != this.zoom && null != this.center) {\n        this.setView(changes['center'].currentValue, changes['zoom'].currentValue);\n      } // Set the zoom level\n      else if (changes['zoom']) {\n        this.setZoom(changes['zoom'].currentValue);\n      } // Set the map center\n      else if (changes['center']) {\n        this.setCenter(changes['center'].currentValue);\n      } // Other options\n\n\n      if (changes['fitBounds']) {\n        this.setFitBounds(changes['fitBounds'].currentValue);\n      }\n\n      if (changes['maxBounds']) {\n        this.setMaxBounds(changes['maxBounds'].currentValue);\n      }\n\n      if (changes['minZoom']) {\n        this.setMinZoom(changes['minZoom'].currentValue);\n      }\n\n      if (changes['maxZoom']) {\n        this.setMaxZoom(changes['maxZoom'].currentValue);\n      }\n    }\n\n    ngOnDestroy() {\n      // If this directive is destroyed, the map is too\n      if (null != this.map) {\n        this.map.remove();\n      }\n    }\n\n    getMap() {\n      return this.map;\n    }\n\n    onResize() {\n      this.delayResize();\n    }\n\n    addMapEventListeners() {\n      const registerEventHandler = (eventName, handler) => {\n        this.map.on(eventName, handler);\n      }; // Add all the pass-through mouse event handlers\n\n\n      registerEventHandler('click', e => LeafletUtil.handleEvent(this.zone, this.onClick, e));\n      registerEventHandler('dblclick', e => LeafletUtil.handleEvent(this.zone, this.onDoubleClick, e));\n      registerEventHandler('mousedown', e => LeafletUtil.handleEvent(this.zone, this.onMouseDown, e));\n      registerEventHandler('mouseup', e => LeafletUtil.handleEvent(this.zone, this.onMouseUp, e));\n      registerEventHandler('mouseover', e => LeafletUtil.handleEvent(this.zone, this.onMouseOver, e));\n      registerEventHandler('mouseout', e => LeafletUtil.handleEvent(this.zone, this.onMouseOut, e));\n      registerEventHandler('mousemove', e => LeafletUtil.handleEvent(this.zone, this.onMouseMove, e));\n      registerEventHandler('zoomstart', e => LeafletUtil.handleEvent(this.zone, this.onMapZoomStart, e));\n      registerEventHandler('zoom', e => LeafletUtil.handleEvent(this.zone, this.onMapZoom, e));\n      registerEventHandler('zoomend', e => LeafletUtil.handleEvent(this.zone, this.onMapZoomEnd, e));\n      registerEventHandler('movestart', e => LeafletUtil.handleEvent(this.zone, this.onMapMoveStart, e));\n      registerEventHandler('move', e => LeafletUtil.handleEvent(this.zone, this.onMapMove, e));\n      registerEventHandler('moveend', e => LeafletUtil.handleEvent(this.zone, this.onMapMoveEnd, e)); // Update any things for which we provide output bindings\n\n      const outputUpdateHandler = () => {\n        const zoom = this.map.getZoom();\n\n        if (zoom !== this.zoom) {\n          this.zoom = zoom;\n          LeafletUtil.handleEvent(this.zone, this.zoomChange, zoom);\n        }\n\n        const center = this.map.getCenter();\n\n        if (null != center || null != this.center) {\n          if ((null == center || null == this.center) && center !== this.center || center.lat !== this.center.lat || center.lng !== this.center.lng) {\n            this.center = center;\n            LeafletUtil.handleEvent(this.zone, this.centerChange, center);\n          }\n        }\n      };\n\n      registerEventHandler('moveend', outputUpdateHandler);\n      registerEventHandler('zoomend', outputUpdateHandler);\n    }\n    /**\n     * Resize the map to fit it's parent container\n     */\n\n\n    doResize() {\n      // Run this outside of angular so the map events stay outside of angular\n      this.zone.runOutsideAngular(() => {\n        // Invalidate the map size to trigger it to update itself\n        if (null != this.map) {\n          this.map.invalidateSize({});\n        }\n      });\n    }\n    /**\n     * Manage a delayed resize of the component\n     */\n\n\n    delayResize() {\n      if (null != this.resizeTimer) {\n        clearTimeout(this.resizeTimer);\n      }\n\n      this.resizeTimer = setTimeout(this.doResize.bind(this), 200);\n    }\n    /**\n     * Set the view (center/zoom) all at once\n     * @param center The new center\n     * @param zoom The new zoom level\n     */\n\n\n    setView(center, zoom) {\n      if (null != this.map && null != center && null != zoom) {\n        this.map.setView(center, zoom, this.zoomPanOptions);\n      }\n    }\n    /**\n     * Set the map zoom level\n     * @param zoom the new zoom level for the map\n     */\n\n\n    setZoom(zoom) {\n      if (null != this.map && null != zoom) {\n        this.map.setZoom(zoom, this.zoomOptions);\n      }\n    }\n    /**\n     * Set the center of the map\n     * @param center the center point\n     */\n\n\n    setCenter(center) {\n      if (null != this.map && null != center) {\n        this.map.panTo(center, this.panOptions);\n      }\n    }\n    /**\n     * Fit the map to the bounds\n     * @param latLngBounds the boundary to set\n     */\n\n\n    setFitBounds(latLngBounds) {\n      if (null != this.map && null != latLngBounds) {\n        this.map.fitBounds(latLngBounds, this.fitBoundsOptions);\n      }\n    }\n    /**\n     * Set the map's max bounds\n     * @param latLngBounds the boundary to set\n     */\n\n\n    setMaxBounds(latLngBounds) {\n      if (null != this.map && null != latLngBounds) {\n        this.map.setMaxBounds(latLngBounds);\n      }\n    }\n    /**\n     * Set the map's min zoom\n     * @param number the new min zoom\n     */\n\n\n    setMinZoom(zoom) {\n      if (null != this.map && null != zoom) {\n        this.map.setMinZoom(zoom);\n      }\n    }\n    /**\n     * Set the map's min zoom\n     * @param number the new min zoom\n     */\n\n\n    setMaxZoom(zoom) {\n      if (null != this.map && null != zoom) {\n        this.map.setMaxZoom(zoom);\n      }\n    }\n\n  }\n\n  LeafletDirective.ɵfac = function LeafletDirective_Factory(t) {\n    return new (t || LeafletDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  LeafletDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LeafletDirective,\n    selectors: [[\"\", \"leaflet\", \"\"]],\n    hostBindings: function LeafletDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"resize\", function LeafletDirective_resize_HostBindingHandler() {\n          return ctx.onResize();\n        }, false, i0.ɵɵresolveWindow);\n      }\n    },\n    inputs: {\n      fitBoundsOptions: [\"leafletFitBoundsOptions\", \"fitBoundsOptions\"],\n      panOptions: [\"leafletPanOptions\", \"panOptions\"],\n      zoomOptions: [\"leafletZoomOptions\", \"zoomOptions\"],\n      zoomPanOptions: [\"leafletZoomPanOptions\", \"zoomPanOptions\"],\n      options: [\"leafletOptions\", \"options\"],\n      zoom: [\"leafletZoom\", \"zoom\"],\n      center: [\"leafletCenter\", \"center\"],\n      fitBounds: [\"leafletFitBounds\", \"fitBounds\"],\n      maxBounds: [\"leafletMaxBounds\", \"maxBounds\"],\n      minZoom: [\"leafletMinZoom\", \"minZoom\"],\n      maxZoom: [\"leafletMaxZoom\", \"maxZoom\"]\n    },\n    outputs: {\n      mapReady: \"leafletMapReady\",\n      zoomChange: \"leafletZoomChange\",\n      centerChange: \"leafletCenterChange\",\n      onClick: \"leafletClick\",\n      onDoubleClick: \"leafletDoubleClick\",\n      onMouseDown: \"leafletMouseDown\",\n      onMouseUp: \"leafletMouseUp\",\n      onMouseMove: \"leafletMouseMove\",\n      onMouseOver: \"leafletMouseOver\",\n      onMouseOut: \"leafletMouseOut\",\n      onMapMove: \"leafletMapMove\",\n      onMapMoveStart: \"leafletMapMoveStart\",\n      onMapMoveEnd: \"leafletMapMoveEnd\",\n      onMapZoom: \"leafletMapZoom\",\n      onMapZoomStart: \"leafletMapZoomStart\",\n      onMapZoomEnd: \"leafletMapZoomEnd\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return LeafletDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nclass LeafletDirectiveWrapper {\n  constructor(leafletDirective) {\n    this.leafletDirective = leafletDirective;\n  }\n\n  init() {// Nothing for now\n  }\n\n  getMap() {\n    return this.leafletDirective.getMap();\n  }\n\n}\n/**\n * Layer directive\n *\n * This directive is used to directly control a single map layer. The purpose of this directive is to\n * be used as part of a child structural directive of the map element.\n *\n */\n\n\nlet LeafletLayerDirective = /*#__PURE__*/(() => {\n  class LeafletLayerDirective {\n    constructor(leafletDirective, zone) {\n      this.zone = zone; // Layer Events\n\n      this.onAdd = new EventEmitter();\n      this.onRemove = new EventEmitter();\n      this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n    }\n\n    ngOnInit() {\n      // Init the map\n      this.leafletDirective.init();\n    }\n\n    ngOnDestroy() {\n      if (null != this.layer) {\n        // Unregister the event handlers\n        this.removeLayerEventListeners(this.layer); // Remove the layer from the map\n\n        this.layer.remove();\n      }\n    }\n\n    ngOnChanges(changes) {\n      if (changes['layer']) {\n        // Update the layer\n        const p = changes['layer'].previousValue;\n        const n = changes['layer'].currentValue;\n        this.zone.runOutsideAngular(() => {\n          if (null != p) {\n            this.removeLayerEventListeners(p);\n            p.remove();\n          }\n\n          if (null != n) {\n            this.addLayerEventListeners(n);\n            this.leafletDirective.getMap().addLayer(n);\n          }\n        });\n      }\n    }\n\n    addLayerEventListeners(l) {\n      this.onAddLayerHandler = e => LeafletUtil.handleEvent(this.zone, this.onAdd, e);\n\n      l.on('add', this.onAddLayerHandler);\n\n      this.onRemoveLayerHandler = e => LeafletUtil.handleEvent(this.zone, this.onRemove, e);\n\n      l.on('remove', this.onRemoveLayerHandler);\n    }\n\n    removeLayerEventListeners(l) {\n      l.off('add', this.onAddLayerHandler);\n      l.off('remove', this.onRemoveLayerHandler);\n    }\n\n  }\n\n  LeafletLayerDirective.ɵfac = function LeafletLayerDirective_Factory(t) {\n    return new (t || LeafletLayerDirective)(i0.ɵɵdirectiveInject(LeafletDirective), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  LeafletLayerDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LeafletLayerDirective,\n    selectors: [[\"\", \"leafletLayer\", \"\"]],\n    inputs: {\n      layer: [\"leafletLayer\", \"layer\"]\n    },\n    outputs: {\n      onAdd: \"leafletLayerAdd\",\n      onRemove: \"leafletLayerRemove\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return LeafletLayerDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Layers directive\n *\n * This directive is used to directly control map layers. As changes are made to the input array of\n * layers, the map is synched to the array. As layers are added or removed from the input array, they\n * are also added or removed from the map. The input array is treated as immutable. To detect changes,\n * you must change the array instance.\n *\n * Important Note: The input layers array is assumed to be immutable. This means you need to use an\n * immutable array implementation or create a new copy of your array when you make changes, otherwise\n * this directive won't detect the change. This is by design. It's for performance reasons. Change\n * detection of mutable arrays requires diffing the state of the array on every DoCheck cycle, which\n * is extremely expensive from a time complexity perspective.\n *\n */\n\n\nlet LeafletLayersDirective = /*#__PURE__*/(() => {\n  class LeafletLayersDirective {\n    constructor(leafletDirective, differs, zone) {\n      this.differs = differs;\n      this.zone = zone;\n      this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n      this.layersDiffer = this.differs.find([]).create();\n    } // Set/get the layers\n\n\n    set layers(v) {\n      this.layersValue = v; // Now that we have a differ, do an immediate layer update\n\n      this.updateLayers();\n    }\n\n    get layers() {\n      return this.layersValue;\n    }\n\n    ngDoCheck() {\n      this.updateLayers();\n    }\n\n    ngOnInit() {\n      // Init the map\n      this.leafletDirective.init(); // Update layers once the map is ready\n\n      this.updateLayers();\n    }\n\n    ngOnDestroy() {\n      this.layers = [];\n    }\n    /**\n     * Update the state of the layers.\n     * We use an iterable differ to synchronize the map layers with the state of the bound layers array.\n     * This is important because it allows us to react to changes to the contents of the array as well\n     * as changes to the actual array instance.\n     */\n\n\n    updateLayers() {\n      const map = this.leafletDirective.getMap();\n\n      if (null != map && null != this.layersDiffer) {\n        const changes = this.layersDiffer.diff(this.layersValue);\n\n        if (null != changes) {\n          // Run outside angular to ensure layer events don't trigger change detection\n          this.zone.runOutsideAngular(() => {\n            changes.forEachRemovedItem(c => {\n              map.removeLayer(c.item);\n            });\n            changes.forEachAddedItem(c => {\n              map.addLayer(c.item);\n            });\n          });\n        }\n      }\n    }\n\n  }\n\n  LeafletLayersDirective.ɵfac = function LeafletLayersDirective_Factory(t) {\n    return new (t || LeafletLayersDirective)(i0.ɵɵdirectiveInject(LeafletDirective), i0.ɵɵdirectiveInject(i0.IterableDiffers), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  LeafletLayersDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LeafletLayersDirective,\n    selectors: [[\"\", \"leafletLayers\", \"\"]],\n    inputs: {\n      layers: [\"leafletLayers\", \"layers\"]\n    }\n  });\n  return LeafletLayersDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nclass LeafletControlLayersChanges {\n  constructor() {\n    this.layersRemoved = 0;\n    this.layersChanged = 0;\n    this.layersAdded = 0;\n  }\n\n  changed() {\n    return !(this.layersRemoved === 0 && this.layersChanged === 0 && this.layersAdded === 0);\n  }\n\n}\n\nclass LeafletControlLayersWrapper {\n  constructor(zone, layersControlReady) {\n    this.zone = zone;\n    this.layersControlReady = layersControlReady;\n  }\n\n  getLayersControl() {\n    return this.layersControl;\n  }\n\n  init(controlConfig, controlOptions) {\n    const baseLayers = controlConfig.baseLayers || {};\n    const overlays = controlConfig.overlays || {}; // Create the control outside of angular to ensure events don't trigger change detection\n\n    this.zone.runOutsideAngular(() => {\n      this.layersControl = control.layers(baseLayers, overlays, controlOptions);\n    });\n    this.layersControlReady.emit(this.layersControl);\n    return this.layersControl;\n  }\n\n  applyBaseLayerChanges(changes) {\n    let results = new LeafletControlLayersChanges();\n\n    if (null != this.layersControl) {\n      results = this.applyChanges(changes, this.layersControl.addBaseLayer);\n    }\n\n    return results;\n  }\n\n  applyOverlayChanges(changes) {\n    let results = new LeafletControlLayersChanges();\n\n    if (null != this.layersControl) {\n      results = this.applyChanges(changes, this.layersControl.addOverlay);\n    }\n\n    return results;\n  }\n\n  applyChanges(changes, addFn) {\n    const results = new LeafletControlLayersChanges();\n\n    if (null != changes) {\n      // All layer management is outside angular to avoid layer events from triggering change detection\n      this.zone.runOutsideAngular(() => {\n        changes.forEachChangedItem(c => {\n          this.layersControl.removeLayer(c.previousValue);\n          addFn.call(this.layersControl, c.currentValue, c.key);\n          results.layersChanged++;\n        });\n        changes.forEachRemovedItem(c => {\n          this.layersControl.removeLayer(c.previousValue);\n          results.layersRemoved++;\n        });\n        changes.forEachAddedItem(c => {\n          addFn.call(this.layersControl, c.currentValue, c.key);\n          results.layersAdded++;\n        });\n      });\n    }\n\n    return results;\n  }\n\n}\n\nclass LeafletControlLayersConfig {\n  constructor() {\n    this.baseLayers = {};\n    this.overlays = {};\n  }\n\n}\n/**\n * Layers Control\n *\n * This directive is used to configure the layers control. The input accepts an object with two\n * key-value maps of layer name -> layer. Mutable changes are detected. On changes, a differ is\n * used to determine what changed so that layers are appropriately added or removed.\n *\n * To specify which layer to show as the 'active' baselayer, you will want to add it to the map\n * using the layers directive. Otherwise, the last one it sees will be used.\n */\n\n\nlet LeafletLayersControlDirective = /*#__PURE__*/(() => {\n  class LeafletLayersControlDirective {\n    constructor(leafletDirective, differs, zone) {\n      this.differs = differs;\n      this.zone = zone;\n      this.layersControlReady = new EventEmitter();\n      this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n      this.controlLayers = new LeafletControlLayersWrapper(this.zone, this.layersControlReady); // Generate differs\n\n      this.baseLayersDiffer = this.differs.find({}).create();\n      this.overlaysDiffer = this.differs.find({}).create();\n    }\n\n    set layersControlConfig(v) {\n      // Validation/init stuff\n      if (null == v) {\n        v = new LeafletControlLayersConfig();\n      }\n\n      if (null == v.baseLayers) {\n        v.baseLayers = {};\n      }\n\n      if (null == v.overlays) {\n        v.overlays = {};\n      } // Store the value\n\n\n      this.layersControlConfigValue = v; // Update the map\n\n      this.updateLayers();\n    }\n\n    get layersControlConfig() {\n      return this.layersControlConfigValue;\n    }\n\n    ngOnInit() {\n      // Init the map\n      this.leafletDirective.init(); // Set up control outside of angular to avoid change detection when using the control\n\n      this.zone.runOutsideAngular(() => {\n        // Set up all the initial settings\n        this.controlLayers.init({}, this.layersControlOptions).addTo(this.leafletDirective.getMap());\n      });\n      this.updateLayers();\n    }\n\n    ngOnDestroy() {\n      this.layersControlConfig = {\n        baseLayers: {},\n        overlays: {}\n      };\n      this.controlLayers.getLayersControl().remove();\n    }\n\n    ngDoCheck() {\n      this.updateLayers();\n    }\n\n    updateLayers() {\n      const map = this.leafletDirective.getMap();\n      const layersControl = this.controlLayers.getLayersControl();\n\n      if (null != map && null != layersControl) {\n        // Run the baselayers differ\n        if (null != this.baseLayersDiffer && null != this.layersControlConfigValue.baseLayers) {\n          const changes = this.baseLayersDiffer.diff(this.layersControlConfigValue.baseLayers);\n          this.controlLayers.applyBaseLayerChanges(changes);\n        } // Run the overlays differ\n\n\n        if (null != this.overlaysDiffer && null != this.layersControlConfigValue.overlays) {\n          const changes = this.overlaysDiffer.diff(this.layersControlConfigValue.overlays);\n          this.controlLayers.applyOverlayChanges(changes);\n        }\n      }\n    }\n\n  }\n\n  LeafletLayersControlDirective.ɵfac = function LeafletLayersControlDirective_Factory(t) {\n    return new (t || LeafletLayersControlDirective)(i0.ɵɵdirectiveInject(LeafletDirective), i0.ɵɵdirectiveInject(i0.KeyValueDiffers), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  LeafletLayersControlDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LeafletLayersControlDirective,\n    selectors: [[\"\", \"leafletLayersControl\", \"\"]],\n    inputs: {\n      layersControlConfig: [\"leafletLayersControl\", \"layersControlConfig\"],\n      layersControlOptions: [\"leafletLayersControlOptions\", \"layersControlOptions\"]\n    },\n    outputs: {\n      layersControlReady: \"leafletLayersControlReady\"\n    }\n  });\n  return LeafletLayersControlDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Baselayers directive\n *\n * This directive is provided as a convenient way to add baselayers to the map. The input accepts\n * a key-value map of layer name -> layer. Mutable changed are detected. On changes, a differ is\n * used to determine what changed so that layers are appropriately added or removed. This directive\n * will also add the layers control so users can switch between available base layers.\n *\n * To specify which layer to show as the 'active' baselayer, you will want to add it to the map\n * using the layers directive. Otherwise, the plugin will use the last one it sees.\n */\n\n\nlet LeafletBaseLayersDirective = /*#__PURE__*/(() => {\n  class LeafletBaseLayersDirective {\n    constructor(leafletDirective, differs, zone) {\n      this.differs = differs;\n      this.zone = zone; // Output for once the layers control is ready\n\n      this.layersControlReady = new EventEmitter();\n      this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n      this.controlLayers = new LeafletControlLayersWrapper(this.zone, this.layersControlReady);\n      this.baseLayersDiffer = this.differs.find({}).create();\n    } // Set/get baseLayers\n\n\n    set baseLayers(v) {\n      this.baseLayersValue = v;\n      this.updateBaseLayers();\n    }\n\n    get baseLayers() {\n      return this.baseLayersValue;\n    }\n\n    ngOnDestroy() {\n      this.baseLayers = {};\n\n      if (null != this.controlLayers.getLayersControl()) {\n        this.controlLayers.getLayersControl().remove();\n      }\n    }\n\n    ngOnInit() {\n      // Init the map\n      this.leafletDirective.init(); // Create the control outside angular to prevent events from triggering chnage detection\n\n      this.zone.runOutsideAngular(() => {\n        // Initially configure the controlLayers\n        this.controlLayers.init({}, this.layersControlOptions).addTo(this.leafletDirective.getMap());\n      });\n      this.updateBaseLayers();\n    }\n\n    ngDoCheck() {\n      this.updateBaseLayers();\n    }\n\n    updateBaseLayers() {\n      const map = this.leafletDirective.getMap();\n      const layersControl = this.controlLayers.getLayersControl();\n\n      if (null != map && null != layersControl && null != this.baseLayersDiffer) {\n        const changes = this.baseLayersDiffer.diff(this.baseLayersValue);\n        const results = this.controlLayers.applyBaseLayerChanges(changes);\n\n        if (results.changed()) {\n          this.syncBaseLayer();\n        }\n      }\n    }\n    /**\n     * Check the current base layer and change it to the new one if necessary\n     */\n\n\n    syncBaseLayer() {\n      const map = this.leafletDirective.getMap();\n      const layers = LeafletUtil.mapToArray(this.baseLayers);\n      let foundLayer; // Search all the layers in the map to see if we can find them in the baselayer array\n\n      map.eachLayer(l => {\n        foundLayer = layers.find(bl => l === bl);\n      }); // Did we find the layer?\n\n      if (null != foundLayer) {\n        // Yes - set the baselayer to the one we found\n        this.baseLayer = foundLayer;\n      } else {\n        // No - set the baselayer to the first in the array and add it to the map\n        if (layers.length > 0) {\n          this.baseLayer = layers[0]; // Add layers outside of angular to prevent events from triggering change detection\n\n          this.zone.runOutsideAngular(() => {\n            this.baseLayer.addTo(map);\n          });\n        }\n      }\n    }\n\n  }\n\n  LeafletBaseLayersDirective.ɵfac = function LeafletBaseLayersDirective_Factory(t) {\n    return new (t || LeafletBaseLayersDirective)(i0.ɵɵdirectiveInject(LeafletDirective), i0.ɵɵdirectiveInject(i0.KeyValueDiffers), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  LeafletBaseLayersDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LeafletBaseLayersDirective,\n    selectors: [[\"\", \"leafletBaseLayers\", \"\"]],\n    inputs: {\n      baseLayers: [\"leafletBaseLayers\", \"baseLayers\"],\n      layersControlOptions: [\"leafletLayersControlOptions\", \"layersControlOptions\"]\n    },\n    outputs: {\n      layersControlReady: \"leafletLayersControlReady\"\n    }\n  });\n  return LeafletBaseLayersDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet LeafletModule = /*#__PURE__*/(() => {\n  class LeafletModule {}\n\n  LeafletModule.ɵfac = function LeafletModule_Factory(t) {\n    return new (t || LeafletModule)();\n  };\n\n  LeafletModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: LeafletModule\n  });\n  LeafletModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return LeafletModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nclass LeafletTileLayerDefinition {\n  constructor(type, url, options) {\n    this.type = type;\n    this.url = url;\n    this.options = options;\n  }\n  /**\n   * Creates a TileLayer from the provided definition. This is a convenience function\n   * to help with generating layers from objects.\n   *\n   * @param layerDef The layer to create\n   * @returns {TileLayer} The TileLayer that has been created\n   */\n\n\n  static createTileLayer(layerDef) {\n    let layer;\n\n    switch (layerDef.type) {\n      case 'xyz':\n        layer = tileLayer(layerDef.url, layerDef.options);\n        break;\n\n      case 'wms':\n      default:\n        layer = tileLayer.wms(layerDef.url, layerDef.options);\n        break;\n    }\n\n    return layer;\n  }\n  /**\n   * Creates a TileLayer for each key in the incoming map. This is a convenience function\n   * for generating an associative array of layers from an associative array of objects\n   *\n   * @param layerDefs A map of key to tile layer definition\n   * @returns {{[p: string]: TileLayer}} A new map of key to TileLayer\n   */\n\n\n  static createTileLayers(layerDefs) {\n    const layers = {};\n\n    for (const k in layerDefs) {\n      if (layerDefs.hasOwnProperty(k)) {\n        layers[k] = LeafletTileLayerDefinition.createTileLayer(layerDefs[k]);\n      }\n    }\n\n    return layers;\n  }\n  /**\n   * Create a Tile Layer from the current state of this object\n   *\n   * @returns {TileLayer} A new TileLayer\n   */\n\n\n  createTileLayer() {\n    return LeafletTileLayerDefinition.createTileLayer(this);\n  }\n\n}\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { LeafletBaseLayersDirective, LeafletControlLayersChanges, LeafletControlLayersConfig, LeafletControlLayersWrapper, LeafletDirective, LeafletDirectiveWrapper, LeafletLayerDirective, LeafletLayersControlDirective, LeafletLayersDirective, LeafletModule, LeafletTileLayerDefinition, LeafletUtil }; //# sourceMappingURL=asymmetrik-ngx-leaflet.mjs.map","map":null,"metadata":{},"sourceType":"module"}