{"ast":null,"code":"/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n/* Vincenty Direct Solution of Geodesics on the Ellipsoid (c) Chris Veness 2005-2012              */\n\n/*                                                                                                */\n\n/* from: Vincenty direct formula - T Vincenty, \"Direct and Inverse Solutions of Geodesics on the  */\n\n/*       Ellipsoid with application of nested equations\", Survey Review, vol XXII no 176, 1975    */\n\n/*       http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf                                             */\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\nfunction toRad(Value) {\n  /** Converts numeric degrees to radians */\n  return Value * Math.PI / 180;\n}\n\nfunction toDeg(Value) {\n  /** Converts radians to numeric degrees */\n  return Value * 180 / Math.PI;\n}\n\nfunction distVincenty(lat1, lon1, lat2, lon2, callback) {\n  var a = 6378137,\n      b = 6356752.314245,\n      f = 1 / 298.257223563; // WGS-84 ellipsoid params\n\n  var L = toRad(lon2 - lon1);\n  var U1 = Math.atan((1 - f) * Math.tan(toRad(lat1)));\n  var U2 = Math.atan((1 - f) * Math.tan(toRad(lat2)));\n  var sinU1 = Math.sin(U1),\n      cosU1 = Math.cos(U1);\n  var sinU2 = Math.sin(U2),\n      cosU2 = Math.cos(U2);\n  var lambda = L,\n      lambdaP,\n      iterLimit = 100;\n\n  do {\n    var sinLambda = Math.sin(lambda),\n        cosLambda = Math.cos(lambda);\n    var sinSigma = Math.sqrt(cosU2 * sinLambda * (cosU2 * sinLambda) + (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda) * (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));\n\n    if (sinSigma == 0) {\n      var result = {\n        distance: 0,\n        initialBearing: 0,\n        finalBearing: 0\n      };\n\n      if (callback !== undefined && callback instanceof Function) {\n        if (callback.length === 3) {\n          callback(result.distance, result.initialBearing, result.finalBearing);\n        } else {\n          callback(result.distance);\n        }\n      }\n\n      return result;\n    }\n\n    ; // co-incident points\n\n    var cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;\n    var sigma = Math.atan2(sinSigma, cosSigma);\n    var sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma;\n    var cosSqAlpha = 1 - sinAlpha * sinAlpha;\n    var cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha;\n    if (isNaN(cos2SigmaM)) cos2SigmaM = 0; // equatorial line: cosSqAlpha=0 (ยง6)\n\n    var C = f / 16 * cosSqAlpha * (4 + f * (4 - 3 * cosSqAlpha));\n    lambdaP = lambda;\n    lambda = L + (1 - C) * f * sinAlpha * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));\n  } while (Math.abs(lambda - lambdaP) > 1e-12 && --iterLimit > 0);\n\n  if (iterLimit == 0) return NaN; // formula failed to converge\n\n  var uSq = cosSqAlpha * (a * a - b * b) / (b * b);\n  var A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));\n  var B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));\n  var deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));\n  var s = b * A * (sigma - deltaSigma);\n  s = Number(s.toFixed(3)); // round to 1mm precision\n  // note: to return initial/final bearings in addition to distance, use something like:\n\n  var fwdAz = Math.atan2(cosU2 * sinLambda, cosU1 * sinU2 - sinU1 * cosU2 * cosLambda);\n  var revAz = Math.atan2(cosU1 * sinLambda, -sinU1 * cosU2 + cosU1 * sinU2 * cosLambda);\n  var result = {\n    distance: s,\n    initialBearing: toDeg(fwdAz),\n    finalBearing: toDeg(revAz)\n  };\n\n  if (callback !== undefined && callback instanceof Function) {\n    if (callback.length === 3) {\n      callback(result.distance, result.initialBearing, result.finalBearing);\n    } else {\n      callback(result.distance);\n    }\n  }\n\n  return result;\n}\n/**\n * Calculates destination point given start point lat/long, bearing & distance,\n * using Vincenty inverse formula for ellipsoids\n *\n * @param   {Number} lat1, lon1: first point in decimal degrees\n * @param   {Number} brng: initial bearing in decimal degrees\n * @param   {Number} dist: distance along bearing in metres\n * @returns (LatLon} destination point\n */\n\n\nfunction destVincenty(lat1, lon1, brng, dist, callback) {\n  var a = 6378137,\n      b = 6356752.3142,\n      f = 1 / 298.257223563; // WGS-84 ellipsiod\n\n  var s = dist;\n  var alpha1 = toRad(brng);\n  var sinAlpha1 = Math.sin(alpha1);\n  var cosAlpha1 = Math.cos(alpha1);\n  var tanU1 = (1 - f) * Math.tan(toRad(lat1));\n  var cosU1 = 1 / Math.sqrt(1 + tanU1 * tanU1),\n      sinU1 = tanU1 * cosU1;\n  var sigma1 = Math.atan2(tanU1, cosAlpha1);\n  var sinAlpha = cosU1 * sinAlpha1;\n  var cosSqAlpha = 1 - sinAlpha * sinAlpha;\n  var uSq = cosSqAlpha * (a * a - b * b) / (b * b);\n  var A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));\n  var B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));\n  var sigma = s / (b * A),\n      sigmaP = 2 * Math.PI;\n\n  while (Math.abs(sigma - sigmaP) > 1e-12) {\n    var cos2SigmaM = Math.cos(2 * sigma1 + sigma);\n    var sinSigma = Math.sin(sigma);\n    var cosSigma = Math.cos(sigma);\n    var deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));\n    sigmaP = sigma;\n    sigma = s / (b * A) + deltaSigma;\n  }\n\n  var tmp = sinU1 * sinSigma - cosU1 * cosSigma * cosAlpha1;\n  var lat2 = Math.atan2(sinU1 * cosSigma + cosU1 * sinSigma * cosAlpha1, (1 - f) * Math.sqrt(sinAlpha * sinAlpha + tmp * tmp));\n  var lambda = Math.atan2(sinSigma * sinAlpha1, cosU1 * cosSigma - sinU1 * sinSigma * cosAlpha1);\n  var C = f / 16 * cosSqAlpha * (4 + f * (4 - 3 * cosSqAlpha));\n  var L = lambda - (1 - C) * f * sinAlpha * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));\n  var lon2 = (toRad(lon1) + L + 3 * Math.PI) % (2 * Math.PI) - Math.PI; // normalise to -180...+180\n\n  var revAz = Math.atan2(sinAlpha, -tmp); // final bearing, if required\n\n  var result = {\n    lat: toDeg(lat2),\n    lon: toDeg(lon2),\n    finalBearing: toDeg(revAz)\n  };\n\n  if (callback !== undefined && callback instanceof Function) {\n    if (callback.length === 3) {\n      callback(result.lat, result.lon, result.finalBearing);\n    } else {\n      callback(result);\n    }\n  }\n\n  return result;\n}\n\nexports.distVincenty = distVincenty;\nexports.destVincenty = destVincenty;","map":null,"metadata":{},"sourceType":"script"}