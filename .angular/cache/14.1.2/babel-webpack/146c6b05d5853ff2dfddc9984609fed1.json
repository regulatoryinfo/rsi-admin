{"ast":null,"code":"\"use strict\";\n\nfunction __$strToBlobUri(t, e, r) {\n  try {\n    return window.URL.createObjectURL(new Blob([Uint8Array.from(t.split(\"\").map(function (t) {\n      return t.charCodeAt(0);\n    }))], {\n      type: e\n    }));\n  } catch (i) {\n    return \"data:\" + e + (r ? \";base64,\" : \",\") + t;\n  }\n}\n\nfunction Pbf(t) {\n  this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t) ? t : new Uint8Array(t || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;\n}\n\nfunction readVarintRemainder(t, e, r) {\n  var i,\n      n,\n      o = r.buf;\n  if (n = o[r.pos++], i = (112 & n) >> 4, n < 128) return toNum(t, i, e);\n  if (n = o[r.pos++], i |= (127 & n) << 3, n < 128) return toNum(t, i, e);\n  if (n = o[r.pos++], i |= (127 & n) << 10, n < 128) return toNum(t, i, e);\n  if (n = o[r.pos++], i |= (127 & n) << 17, n < 128) return toNum(t, i, e);\n  if (n = o[r.pos++], i |= (127 & n) << 24, n < 128) return toNum(t, i, e);\n  if (n = o[r.pos++], i |= (1 & n) << 31, n < 128) return toNum(t, i, e);\n  throw new Error(\"Expected varint not more than 10 bytes\");\n}\n\nfunction readPackedEnd(t) {\n  return t.type === Pbf.Bytes ? t.readVarint() + t.pos : t.pos + 1;\n}\n\nfunction toNum(t, e, r) {\n  return r ? 4294967296 * e + (t >>> 0) : 4294967296 * (e >>> 0) + (t >>> 0);\n}\n\nfunction writeBigVarint(t, e) {\n  var r, i;\n  if (t >= 0 ? (r = t % 4294967296 | 0, i = t / 4294967296 | 0) : (r = ~(-t % 4294967296), i = ~(-t / 4294967296), 4294967295 ^ r ? r = r + 1 | 0 : (r = 0, i = i + 1 | 0)), t >= 0x10000000000000000 || t < -0x10000000000000000) throw new Error(\"Given varint doesn't fit into 10 bytes\");\n  e.realloc(10), writeBigVarintLow(r, i, e), writeBigVarintHigh(i, e);\n}\n\nfunction writeBigVarintLow(t, e, r) {\n  r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos] = 127 & t;\n}\n\nfunction writeBigVarintHigh(t, e) {\n  var r = (7 & t) << 4;\n  e.buf[e.pos++] |= r | ((t >>>= 3) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t)))));\n}\n\nfunction makeRoomForExtraLength(t, e, r) {\n  var i = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.ceil(Math.log(e) / (7 * Math.LN2));\n  r.realloc(i);\n\n  for (var n = r.pos - 1; n >= t; n--) r.buf[n + i] = r.buf[n];\n}\n\nfunction writePackedVarint(t, e) {\n  for (var r = 0; r < t.length; r++) e.writeVarint(t[r]);\n}\n\nfunction writePackedSVarint(t, e) {\n  for (var r = 0; r < t.length; r++) e.writeSVarint(t[r]);\n}\n\nfunction writePackedFloat(t, e) {\n  for (var r = 0; r < t.length; r++) e.writeFloat(t[r]);\n}\n\nfunction writePackedDouble(t, e) {\n  for (var r = 0; r < t.length; r++) e.writeDouble(t[r]);\n}\n\nfunction writePackedBoolean(t, e) {\n  for (var r = 0; r < t.length; r++) e.writeBoolean(t[r]);\n}\n\nfunction writePackedFixed32(t, e) {\n  for (var r = 0; r < t.length; r++) e.writeFixed32(t[r]);\n}\n\nfunction writePackedSFixed32(t, e) {\n  for (var r = 0; r < t.length; r++) e.writeSFixed32(t[r]);\n}\n\nfunction writePackedFixed64(t, e) {\n  for (var r = 0; r < t.length; r++) e.writeFixed64(t[r]);\n}\n\nfunction writePackedSFixed64(t, e) {\n  for (var r = 0; r < t.length; r++) e.writeSFixed64(t[r]);\n}\n\nfunction readUInt32(t, e) {\n  return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + 16777216 * t[e + 3];\n}\n\nfunction writeInt32(t, e, r) {\n  t[r] = e, t[r + 1] = e >>> 8, t[r + 2] = e >>> 16, t[r + 3] = e >>> 24;\n}\n\nfunction readInt32(t, e) {\n  return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + (t[e + 3] << 24);\n}\n\nfunction readUtf8(t, e, r) {\n  for (var i = \"\", n = e; n < r;) {\n    var o = t[n],\n        s = null,\n        a = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1;\n    if (n + a > r) break;\n    var u, h, l;\n    1 === a ? o < 128 && (s = o) : 2 === a ? 128 == (192 & (u = t[n + 1])) && (s = (31 & o) << 6 | 63 & u) <= 127 && (s = null) : 3 === a ? (u = t[n + 1], h = t[n + 2], 128 == (192 & u) && 128 == (192 & h) && ((s = (15 & o) << 12 | (63 & u) << 6 | 63 & h) <= 2047 || s >= 55296 && s <= 57343) && (s = null)) : 4 === a && (u = t[n + 1], h = t[n + 2], l = t[n + 3], 128 == (192 & u) && 128 == (192 & h) && 128 == (192 & l) && ((s = (15 & o) << 18 | (63 & u) << 12 | (63 & h) << 6 | 63 & l) <= 65535 || s >= 1114112) && (s = null)), null === s ? (s = 65533, a = 1) : s > 65535 && (s -= 65536, i += String.fromCharCode(s >>> 10 & 1023 | 55296), s = 56320 | 1023 & s), i += String.fromCharCode(s), n += a;\n  }\n\n  return i;\n}\n\nfunction writeUtf8(t, e, r) {\n  for (var i, n, o = 0; o < e.length; o++) {\n    if ((i = e.charCodeAt(o)) > 55295 && i < 57344) {\n      if (!n) {\n        i > 56319 || o + 1 === e.length ? (t[r++] = 239, t[r++] = 191, t[r++] = 189) : n = i;\n        continue;\n      }\n\n      if (i < 56320) {\n        t[r++] = 239, t[r++] = 191, t[r++] = 189, n = i;\n        continue;\n      }\n\n      i = n - 55296 << 10 | i - 56320 | 65536, n = null;\n    } else n && (t[r++] = 239, t[r++] = 191, t[r++] = 189, n = null);\n\n    i < 128 ? t[r++] = i : (i < 2048 ? t[r++] = i >> 6 | 192 : (i < 65536 ? t[r++] = i >> 12 | 224 : (t[r++] = i >> 18 | 240, t[r++] = i >> 12 & 63 | 128), t[r++] = i >> 6 & 63 | 128), t[r++] = 63 & i | 128);\n  }\n\n  return r;\n}\n\nfunction Point$1(t, e) {\n  this.x = t, this.y = e;\n}\n\nfunction VectorTileFeature$2(t, e, r, i, n) {\n  this.properties = {}, this.extent = r, this.type = 0, this._pbf = t, this._geometry = -1, this._keys = i, this._values = n, t.readFields(readFeature, this, e);\n}\n\nfunction readFeature(t, e, r) {\n  1 == t ? e.id = r.readVarint() : 2 == t ? readTag(r, e) : 3 == t ? e.type = r.readVarint() : 4 == t && (e._geometry = r.pos);\n}\n\nfunction readTag(t, e) {\n  for (var r = t.readVarint() + t.pos; t.pos < r;) {\n    var i = e._keys[t.readVarint()],\n        n = e._values[t.readVarint()];\n\n    e.properties[i] = n;\n  }\n}\n\nfunction classifyRings(t) {\n  var e = t.length;\n  if (e <= 1) return [t];\n\n  for (var r, i, n = [], o = 0; o < e; o++) {\n    var s = signedArea(t[o]);\n    0 !== s && (void 0 === i && (i = s < 0), i === s < 0 ? (r && n.push(r), r = [t[o]]) : r.push(t[o]));\n  }\n\n  return r && n.push(r), n;\n}\n\nfunction signedArea(t) {\n  for (var e, r, i = 0, n = 0, o = t.length, s = o - 1; n < o; s = n++) e = t[n], r = t[s], i += (r.x - e.x) * (e.y + r.y);\n\n  return i;\n}\n\nfunction VectorTileLayer$2(t, e) {\n  this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t, this._keys = [], this._values = [], this._features = [], t.readFields(readLayer, this, e), this.length = this._features.length;\n}\n\nfunction readLayer(t, e, r) {\n  15 === t ? e.version = r.readVarint() : 1 === t ? e.name = r.readString() : 5 === t ? e.extent = r.readVarint() : 2 === t ? e._features.push(r.pos) : 3 === t ? e._keys.push(r.readString()) : 4 === t && e._values.push(readValueMessage(r));\n}\n\nfunction readValueMessage(t) {\n  for (var e = null, r = t.readVarint() + t.pos; t.pos < r;) {\n    var i = t.readVarint() >> 3;\n    e = 1 === i ? t.readString() : 2 === i ? t.readFloat() : 3 === i ? t.readDouble() : 4 === i ? t.readVarint64() : 5 === i ? t.readVarint() : 6 === i ? t.readSVarint() : 7 === i ? t.readBoolean() : null;\n  }\n\n  return e;\n}\n\nfunction VectorTile$1(t, e) {\n  this.layers = t.readFields(readTile, {}, e);\n}\n\nfunction readTile(t, e, r) {\n  if (3 === t) {\n    var i = new VectorTileLayer$1(r, r.readVarint() + r.pos);\n    i.length && (e[i.name] = i);\n  }\n}\n\n!function (t) {\n  function e(t) {\n    if (\"string\" != typeof t && (t = String(t)), /[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(t)) throw new TypeError(\"Invalid character in header field name\");\n    return t.toLowerCase();\n  }\n\n  function r(t) {\n    return \"string\" != typeof t && (t = String(t)), t;\n  }\n\n  function i(t) {\n    var e = {\n      next: function () {\n        var e = t.shift();\n        return {\n          done: void 0 === e,\n          value: e\n        };\n      }\n    };\n    return v.iterable && (e[Symbol.iterator] = function () {\n      return e;\n    }), e;\n  }\n\n  function n(t) {\n    this.map = {}, t instanceof n ? t.forEach(function (t, e) {\n      this.append(e, t);\n    }, this) : Array.isArray(t) ? t.forEach(function (t) {\n      this.append(t[0], t[1]);\n    }, this) : t && Object.getOwnPropertyNames(t).forEach(function (e) {\n      this.append(e, t[e]);\n    }, this);\n  }\n\n  function o(t) {\n    if (t.bodyUsed) return Promise.reject(new TypeError(\"Already read\"));\n    t.bodyUsed = !0;\n  }\n\n  function s(t) {\n    return new Promise(function (e, r) {\n      t.onload = function () {\n        e(t.result);\n      }, t.onerror = function () {\n        r(t.error);\n      };\n    });\n  }\n\n  function a(t) {\n    var e = new FileReader(),\n        r = s(e);\n    return e.readAsArrayBuffer(t), r;\n  }\n\n  function u(t) {\n    var e = new FileReader(),\n        r = s(e);\n    return e.readAsText(t), r;\n  }\n\n  function h(t) {\n    for (var e = new Uint8Array(t), r = new Array(e.length), i = 0; i < e.length; i++) r[i] = String.fromCharCode(e[i]);\n\n    return r.join(\"\");\n  }\n\n  function l(t) {\n    if (t.slice) return t.slice(0);\n    var e = new Uint8Array(t.byteLength);\n    return e.set(new Uint8Array(t)), e.buffer;\n  }\n\n  function c() {\n    return this.bodyUsed = !1, this._initBody = function (t) {\n      if (this._bodyInit = t, t) {\n        if (\"string\" == typeof t) this._bodyText = t;else if (v.blob && Blob.prototype.isPrototypeOf(t)) this._bodyBlob = t;else if (v.formData && FormData.prototype.isPrototypeOf(t)) this._bodyFormData = t;else if (v.searchParams && URLSearchParams.prototype.isPrototypeOf(t)) this._bodyText = t.toString();else if (v.arrayBuffer && v.blob && b(t)) this._bodyArrayBuffer = l(t.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer]);else {\n          if (!v.arrayBuffer || !ArrayBuffer.prototype.isPrototypeOf(t) && !_(t)) throw new Error(\"unsupported BodyInit type\");\n          this._bodyArrayBuffer = l(t);\n        }\n      } else this._bodyText = \"\";\n      this.headers.get(\"content-type\") || (\"string\" == typeof t ? this.headers.set(\"content-type\", \"text/plain;charset=UTF-8\") : this._bodyBlob && this._bodyBlob.type ? this.headers.set(\"content-type\", this._bodyBlob.type) : v.searchParams && URLSearchParams.prototype.isPrototypeOf(t) && this.headers.set(\"content-type\", \"application/x-www-form-urlencoded;charset=UTF-8\"));\n    }, v.blob && (this.blob = function () {\n      var t = o(this);\n      if (t) return t;\n      if (this._bodyBlob) return Promise.resolve(this._bodyBlob);\n      if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer]));\n      if (this._bodyFormData) throw new Error(\"could not read FormData body as blob\");\n      return Promise.resolve(new Blob([this._bodyText]));\n    }, this.arrayBuffer = function () {\n      return this._bodyArrayBuffer ? o(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(a);\n    }), this.text = function () {\n      var t = o(this);\n      if (t) return t;\n      if (this._bodyBlob) return u(this._bodyBlob);\n      if (this._bodyArrayBuffer) return Promise.resolve(h(this._bodyArrayBuffer));\n      if (this._bodyFormData) throw new Error(\"could not read FormData body as text\");\n      return Promise.resolve(this._bodyText);\n    }, v.formData && (this.formData = function () {\n      return this.text().then(d);\n    }), this.json = function () {\n      return this.text().then(JSON.parse);\n    }, this;\n  }\n\n  function f(t) {\n    var e = t.toUpperCase();\n    return w.indexOf(e) > -1 ? e : t;\n  }\n\n  function p(t, e) {\n    e = e || {};\n    var r = e.body;\n\n    if (t instanceof p) {\n      if (t.bodyUsed) throw new TypeError(\"Already read\");\n      this.url = t.url, this.credentials = t.credentials, e.headers || (this.headers = new n(t.headers)), this.method = t.method, this.mode = t.mode, r || null == t._bodyInit || (r = t._bodyInit, t.bodyUsed = !0);\n    } else this.url = String(t);\n\n    if (this.credentials = e.credentials || this.credentials || \"omit\", !e.headers && this.headers || (this.headers = new n(e.headers)), this.method = f(e.method || this.method || \"GET\"), this.mode = e.mode || this.mode || null, this.referrer = null, (\"GET\" === this.method || \"HEAD\" === this.method) && r) throw new TypeError(\"Body not allowed for GET or HEAD requests\");\n\n    this._initBody(r);\n  }\n\n  function d(t) {\n    var e = new FormData();\n    return t.trim().split(\"&\").forEach(function (t) {\n      if (t) {\n        var r = t.split(\"=\"),\n            i = r.shift().replace(/\\+/g, \" \"),\n            n = r.join(\"=\").replace(/\\+/g, \" \");\n        e.append(decodeURIComponent(i), decodeURIComponent(n));\n      }\n    }), e;\n  }\n\n  function y(t) {\n    var e = new n();\n    return t.replace(/\\r?\\n[\\t ]+/g, \" \").split(/\\r?\\n/).forEach(function (t) {\n      var r = t.split(\":\"),\n          i = r.shift().trim();\n\n      if (i) {\n        var n = r.join(\":\").trim();\n        e.append(i, n);\n      }\n    }), e;\n  }\n\n  function m(t, e) {\n    e || (e = {}), this.type = \"default\", this.status = void 0 === e.status ? 200 : e.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = \"statusText\" in e ? e.statusText : \"OK\", this.headers = new n(e.headers), this.url = e.url || \"\", this._initBody(t);\n  }\n\n  if (!t.fetch) {\n    var v = {\n      searchParams: \"URLSearchParams\" in t,\n      iterable: \"Symbol\" in t && \"iterator\" in Symbol,\n      blob: \"FileReader\" in t && \"Blob\" in t && function () {\n        try {\n          return new Blob(), !0;\n        } catch (t) {\n          return !1;\n        }\n      }(),\n      formData: \"FormData\" in t,\n      arrayBuffer: \"ArrayBuffer\" in t\n    };\n    if (v.arrayBuffer) var g = [\"[object Int8Array]\", \"[object Uint8Array]\", \"[object Uint8ClampedArray]\", \"[object Int16Array]\", \"[object Uint16Array]\", \"[object Int32Array]\", \"[object Uint32Array]\", \"[object Float32Array]\", \"[object Float64Array]\"],\n        b = function (t) {\n      return t && DataView.prototype.isPrototypeOf(t);\n    },\n        _ = ArrayBuffer.isView || function (t) {\n      return t && g.indexOf(Object.prototype.toString.call(t)) > -1;\n    };\n    n.prototype.append = function (t, i) {\n      t = e(t), i = r(i);\n      var n = this.map[t];\n      this.map[t] = n ? n + \",\" + i : i;\n    }, n.prototype.delete = function (t) {\n      delete this.map[e(t)];\n    }, n.prototype.get = function (t) {\n      return t = e(t), this.has(t) ? this.map[t] : null;\n    }, n.prototype.has = function (t) {\n      return this.map.hasOwnProperty(e(t));\n    }, n.prototype.set = function (t, i) {\n      this.map[e(t)] = r(i);\n    }, n.prototype.forEach = function (t, e) {\n      var r = this;\n\n      for (var i in this.map) r.map.hasOwnProperty(i) && t.call(e, r.map[i], i, r);\n    }, n.prototype.keys = function () {\n      var t = [];\n      return this.forEach(function (e, r) {\n        t.push(r);\n      }), i(t);\n    }, n.prototype.values = function () {\n      var t = [];\n      return this.forEach(function (e) {\n        t.push(e);\n      }), i(t);\n    }, n.prototype.entries = function () {\n      var t = [];\n      return this.forEach(function (e, r) {\n        t.push([r, e]);\n      }), i(t);\n    }, v.iterable && (n.prototype[Symbol.iterator] = n.prototype.entries);\n    var w = [\"DELETE\", \"GET\", \"HEAD\", \"OPTIONS\", \"POST\", \"PUT\"];\n    p.prototype.clone = function () {\n      return new p(this, {\n        body: this._bodyInit\n      });\n    }, c.call(p.prototype), c.call(m.prototype), m.prototype.clone = function () {\n      return new m(this._bodyInit, {\n        status: this.status,\n        statusText: this.statusText,\n        headers: new n(this.headers),\n        url: this.url\n      });\n    }, m.error = function () {\n      var t = new m(null, {\n        status: 0,\n        statusText: \"\"\n      });\n      return t.type = \"error\", t;\n    };\n    var x = [301, 302, 303, 307, 308];\n    m.redirect = function (t, e) {\n      if (-1 === x.indexOf(e)) throw new RangeError(\"Invalid status code\");\n      return new m(null, {\n        status: e,\n        headers: {\n          location: t\n        }\n      });\n    }, t.Headers = n, t.Request = p, t.Response = m, t.fetch = function (t, e) {\n      return new Promise(function (r, i) {\n        var n = new p(t, e),\n            o = new XMLHttpRequest();\n        o.onload = function () {\n          var t = {\n            status: o.status,\n            statusText: o.statusText,\n            headers: y(o.getAllResponseHeaders() || \"\")\n          };\n          t.url = \"responseURL\" in o ? o.responseURL : t.headers.get(\"X-Request-URL\");\n          var e = \"response\" in o ? o.response : o.responseText;\n          r(new m(e, t));\n        }, o.onerror = function () {\n          i(new TypeError(\"Network request failed\"));\n        }, o.ontimeout = function () {\n          i(new TypeError(\"Network request failed\"));\n        }, o.open(n.method, n.url, !0), \"include\" === n.credentials ? o.withCredentials = !0 : \"omit\" === n.credentials && (o.withCredentials = !1), \"responseType\" in o && v.blob && (o.responseType = \"blob\"), n.headers.forEach(function (t, e) {\n          o.setRequestHeader(e, t);\n        }), o.send(void 0 === n._bodyInit ? null : n._bodyInit);\n      });\n    }, t.fetch.polyfill = !0;\n  }\n}(\"undefined\" != typeof self ? self : void 0);\n\nvar read = function (t, e, r, i, n) {\n  var o,\n      s,\n      a = 8 * n - i - 1,\n      u = (1 << a) - 1,\n      h = u >> 1,\n      l = -7,\n      c = r ? n - 1 : 0,\n      f = r ? -1 : 1,\n      p = t[e + c];\n\n  for (c += f, o = p & (1 << -l) - 1, p >>= -l, l += a; l > 0; o = 256 * o + t[e + c], c += f, l -= 8);\n\n  for (s = o & (1 << -l) - 1, o >>= -l, l += i; l > 0; s = 256 * s + t[e + c], c += f, l -= 8);\n\n  if (0 === o) o = 1 - h;else {\n    if (o === u) return s ? NaN : 1 / 0 * (p ? -1 : 1);\n    s += Math.pow(2, i), o -= h;\n  }\n  return (p ? -1 : 1) * s * Math.pow(2, o - i);\n},\n    write = function (t, e, r, i, n, o) {\n  var s,\n      a,\n      u,\n      h = 8 * o - n - 1,\n      l = (1 << h) - 1,\n      c = l >> 1,\n      f = 23 === n ? Math.pow(2, -24) - Math.pow(2, -77) : 0,\n      p = i ? 0 : o - 1,\n      d = i ? 1 : -1,\n      y = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;\n\n  for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0, s = l) : (s = Math.floor(Math.log(e) / Math.LN2), e * (u = Math.pow(2, -s)) < 1 && (s--, u *= 2), e += s + c >= 1 ? f / u : f * Math.pow(2, 1 - c), e * u >= 2 && (s++, u /= 2), s + c >= l ? (a = 0, s = l) : s + c >= 1 ? (a = (e * u - 1) * Math.pow(2, n), s += c) : (a = e * Math.pow(2, c - 1) * Math.pow(2, n), s = 0)); n >= 8; t[r + p] = 255 & a, p += d, a /= 256, n -= 8);\n\n  for (s = s << n | a, h += n; h > 0; t[r + p] = 255 & s, p += d, s /= 256, h -= 8);\n\n  t[r + p - d] |= 128 * y;\n},\n    index$1 = {\n  read: read,\n  write: write\n},\n    index = Pbf,\n    ieee754 = index$1;\n\nPbf.Varint = 0, Pbf.Fixed64 = 1, Pbf.Bytes = 2, Pbf.Fixed32 = 5;\nvar SHIFT_LEFT_32 = 4294967296,\n    SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;\nPbf.prototype = {\n  destroy: function () {\n    this.buf = null;\n  },\n  readFields: function (t, e, r) {\n    var i = this;\n\n    for (r = r || this.length; this.pos < r;) {\n      var n = i.readVarint(),\n          o = n >> 3,\n          s = i.pos;\n      i.type = 7 & n, t(o, e, i), i.pos === s && i.skip(n);\n    }\n\n    return e;\n  },\n  readMessage: function (t, e) {\n    return this.readFields(t, e, this.readVarint() + this.pos);\n  },\n  readFixed32: function () {\n    var t = readUInt32(this.buf, this.pos);\n    return this.pos += 4, t;\n  },\n  readSFixed32: function () {\n    var t = readInt32(this.buf, this.pos);\n    return this.pos += 4, t;\n  },\n  readFixed64: function () {\n    var t = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;\n    return this.pos += 8, t;\n  },\n  readSFixed64: function () {\n    var t = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;\n    return this.pos += 8, t;\n  },\n  readFloat: function () {\n    var t = ieee754.read(this.buf, this.pos, !0, 23, 4);\n    return this.pos += 4, t;\n  },\n  readDouble: function () {\n    var t = ieee754.read(this.buf, this.pos, !0, 52, 8);\n    return this.pos += 8, t;\n  },\n  readVarint: function (t) {\n    var e,\n        r,\n        i = this.buf;\n    return r = i[this.pos++], e = 127 & r, r < 128 ? e : (r = i[this.pos++], e |= (127 & r) << 7, r < 128 ? e : (r = i[this.pos++], e |= (127 & r) << 14, r < 128 ? e : (r = i[this.pos++], e |= (127 & r) << 21, r < 128 ? e : (r = i[this.pos], e |= (15 & r) << 28, readVarintRemainder(e, t, this)))));\n  },\n  readVarint64: function () {\n    return this.readVarint(!0);\n  },\n  readSVarint: function () {\n    var t = this.readVarint();\n    return t % 2 == 1 ? (t + 1) / -2 : t / 2;\n  },\n  readBoolean: function () {\n    return Boolean(this.readVarint());\n  },\n  readString: function () {\n    var t = this.readVarint() + this.pos,\n        e = readUtf8(this.buf, this.pos, t);\n    return this.pos = t, e;\n  },\n  readBytes: function () {\n    var t = this.readVarint() + this.pos,\n        e = this.buf.subarray(this.pos, t);\n    return this.pos = t, e;\n  },\n  readPackedVarint: function (t, e) {\n    var r = this,\n        i = readPackedEnd(this);\n\n    for (t = t || []; this.pos < i;) t.push(r.readVarint(e));\n\n    return t;\n  },\n  readPackedSVarint: function (t) {\n    var e = this,\n        r = readPackedEnd(this);\n\n    for (t = t || []; this.pos < r;) t.push(e.readSVarint());\n\n    return t;\n  },\n  readPackedBoolean: function (t) {\n    var e = this,\n        r = readPackedEnd(this);\n\n    for (t = t || []; this.pos < r;) t.push(e.readBoolean());\n\n    return t;\n  },\n  readPackedFloat: function (t) {\n    var e = this,\n        r = readPackedEnd(this);\n\n    for (t = t || []; this.pos < r;) t.push(e.readFloat());\n\n    return t;\n  },\n  readPackedDouble: function (t) {\n    var e = this,\n        r = readPackedEnd(this);\n\n    for (t = t || []; this.pos < r;) t.push(e.readDouble());\n\n    return t;\n  },\n  readPackedFixed32: function (t) {\n    var e = this,\n        r = readPackedEnd(this);\n\n    for (t = t || []; this.pos < r;) t.push(e.readFixed32());\n\n    return t;\n  },\n  readPackedSFixed32: function (t) {\n    var e = this,\n        r = readPackedEnd(this);\n\n    for (t = t || []; this.pos < r;) t.push(e.readSFixed32());\n\n    return t;\n  },\n  readPackedFixed64: function (t) {\n    var e = this,\n        r = readPackedEnd(this);\n\n    for (t = t || []; this.pos < r;) t.push(e.readFixed64());\n\n    return t;\n  },\n  readPackedSFixed64: function (t) {\n    var e = this,\n        r = readPackedEnd(this);\n\n    for (t = t || []; this.pos < r;) t.push(e.readSFixed64());\n\n    return t;\n  },\n  skip: function (t) {\n    var e = 7 & t;\n    if (e === Pbf.Varint) for (; this.buf[this.pos++] > 127;);else if (e === Pbf.Bytes) this.pos = this.readVarint() + this.pos;else if (e === Pbf.Fixed32) this.pos += 4;else {\n      if (e !== Pbf.Fixed64) throw new Error(\"Unimplemented type: \" + e);\n      this.pos += 8;\n    }\n  },\n  writeTag: function (t, e) {\n    this.writeVarint(t << 3 | e);\n  },\n  realloc: function (t) {\n    for (var e = this.length || 16; e < this.pos + t;) e *= 2;\n\n    if (e !== this.length) {\n      var r = new Uint8Array(e);\n      r.set(this.buf), this.buf = r, this.length = e;\n    }\n  },\n  finish: function () {\n    return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);\n  },\n  writeFixed32: function (t) {\n    this.realloc(4), writeInt32(this.buf, t, this.pos), this.pos += 4;\n  },\n  writeSFixed32: function (t) {\n    this.realloc(4), writeInt32(this.buf, t, this.pos), this.pos += 4;\n  },\n  writeFixed64: function (t) {\n    this.realloc(8), writeInt32(this.buf, -1 & t, this.pos), writeInt32(this.buf, Math.floor(t * SHIFT_RIGHT_32), this.pos + 4), this.pos += 8;\n  },\n  writeSFixed64: function (t) {\n    this.realloc(8), writeInt32(this.buf, -1 & t, this.pos), writeInt32(this.buf, Math.floor(t * SHIFT_RIGHT_32), this.pos + 4), this.pos += 8;\n  },\n  writeVarint: function (t) {\n    if ((t = +t || 0) > 268435455 || t < 0) return void writeBigVarint(t, this);\n    this.realloc(4), this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127)));\n  },\n  writeSVarint: function (t) {\n    this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t);\n  },\n  writeBoolean: function (t) {\n    this.writeVarint(Boolean(t));\n  },\n  writeString: function (t) {\n    t = String(t), this.realloc(4 * t.length), this.pos++;\n    var e = this.pos;\n    this.pos = writeUtf8(this.buf, t, this.pos);\n    var r = this.pos - e;\n    r >= 128 && makeRoomForExtraLength(e, r, this), this.pos = e - 1, this.writeVarint(r), this.pos += r;\n  },\n  writeFloat: function (t) {\n    this.realloc(4), ieee754.write(this.buf, t, this.pos, !0, 23, 4), this.pos += 4;\n  },\n  writeDouble: function (t) {\n    this.realloc(8), ieee754.write(this.buf, t, this.pos, !0, 52, 8), this.pos += 8;\n  },\n  writeBytes: function (t) {\n    var e = this,\n        r = t.length;\n    this.writeVarint(r), this.realloc(r);\n\n    for (var i = 0; i < r; i++) e.buf[e.pos++] = t[i];\n  },\n  writeRawMessage: function (t, e) {\n    this.pos++;\n    var r = this.pos;\n    t(e, this);\n    var i = this.pos - r;\n    i >= 128 && makeRoomForExtraLength(r, i, this), this.pos = r - 1, this.writeVarint(i), this.pos += i;\n  },\n  writeMessage: function (t, e, r) {\n    this.writeTag(t, Pbf.Bytes), this.writeRawMessage(e, r);\n  },\n  writePackedVarint: function (t, e) {\n    this.writeMessage(t, writePackedVarint, e);\n  },\n  writePackedSVarint: function (t, e) {\n    this.writeMessage(t, writePackedSVarint, e);\n  },\n  writePackedBoolean: function (t, e) {\n    this.writeMessage(t, writePackedBoolean, e);\n  },\n  writePackedFloat: function (t, e) {\n    this.writeMessage(t, writePackedFloat, e);\n  },\n  writePackedDouble: function (t, e) {\n    this.writeMessage(t, writePackedDouble, e);\n  },\n  writePackedFixed32: function (t, e) {\n    this.writeMessage(t, writePackedFixed32, e);\n  },\n  writePackedSFixed32: function (t, e) {\n    this.writeMessage(t, writePackedSFixed32, e);\n  },\n  writePackedFixed64: function (t, e) {\n    this.writeMessage(t, writePackedFixed64, e);\n  },\n  writePackedSFixed64: function (t, e) {\n    this.writeMessage(t, writePackedSFixed64, e);\n  },\n  writeBytesField: function (t, e) {\n    this.writeTag(t, Pbf.Bytes), this.writeBytes(e);\n  },\n  writeFixed32Field: function (t, e) {\n    this.writeTag(t, Pbf.Fixed32), this.writeFixed32(e);\n  },\n  writeSFixed32Field: function (t, e) {\n    this.writeTag(t, Pbf.Fixed32), this.writeSFixed32(e);\n  },\n  writeFixed64Field: function (t, e) {\n    this.writeTag(t, Pbf.Fixed64), this.writeFixed64(e);\n  },\n  writeSFixed64Field: function (t, e) {\n    this.writeTag(t, Pbf.Fixed64), this.writeSFixed64(e);\n  },\n  writeVarintField: function (t, e) {\n    this.writeTag(t, Pbf.Varint), this.writeVarint(e);\n  },\n  writeSVarintField: function (t, e) {\n    this.writeTag(t, Pbf.Varint), this.writeSVarint(e);\n  },\n  writeStringField: function (t, e) {\n    this.writeTag(t, Pbf.Bytes), this.writeString(e);\n  },\n  writeFloatField: function (t, e) {\n    this.writeTag(t, Pbf.Fixed32), this.writeFloat(e);\n  },\n  writeDoubleField: function (t, e) {\n    this.writeTag(t, Pbf.Fixed64), this.writeDouble(e);\n  },\n  writeBooleanField: function (t, e) {\n    this.writeVarintField(t, Boolean(e));\n  }\n};\nvar index$5 = Point$1;\nPoint$1.prototype = {\n  clone: function () {\n    return new Point$1(this.x, this.y);\n  },\n  add: function (t) {\n    return this.clone()._add(t);\n  },\n  sub: function (t) {\n    return this.clone()._sub(t);\n  },\n  mult: function (t) {\n    return this.clone()._mult(t);\n  },\n  div: function (t) {\n    return this.clone()._div(t);\n  },\n  rotate: function (t) {\n    return this.clone()._rotate(t);\n  },\n  matMult: function (t) {\n    return this.clone()._matMult(t);\n  },\n  unit: function () {\n    return this.clone()._unit();\n  },\n  perp: function () {\n    return this.clone()._perp();\n  },\n  round: function () {\n    return this.clone()._round();\n  },\n  mag: function () {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  },\n  equals: function (t) {\n    return this.x === t.x && this.y === t.y;\n  },\n  dist: function (t) {\n    return Math.sqrt(this.distSqr(t));\n  },\n  distSqr: function (t) {\n    var e = t.x - this.x,\n        r = t.y - this.y;\n    return e * e + r * r;\n  },\n  angle: function () {\n    return Math.atan2(this.y, this.x);\n  },\n  angleTo: function (t) {\n    return Math.atan2(this.y - t.y, this.x - t.x);\n  },\n  angleWith: function (t) {\n    return this.angleWithSep(t.x, t.y);\n  },\n  angleWithSep: function (t, e) {\n    return Math.atan2(this.x * e - this.y * t, this.x * t + this.y * e);\n  },\n  _matMult: function (t) {\n    var e = t[0] * this.x + t[1] * this.y,\n        r = t[2] * this.x + t[3] * this.y;\n    return this.x = e, this.y = r, this;\n  },\n  _add: function (t) {\n    return this.x += t.x, this.y += t.y, this;\n  },\n  _sub: function (t) {\n    return this.x -= t.x, this.y -= t.y, this;\n  },\n  _mult: function (t) {\n    return this.x *= t, this.y *= t, this;\n  },\n  _div: function (t) {\n    return this.x /= t, this.y /= t, this;\n  },\n  _unit: function () {\n    return this._div(this.mag()), this;\n  },\n  _perp: function () {\n    var t = this.y;\n    return this.y = this.x, this.x = -t, this;\n  },\n  _rotate: function (t) {\n    var e = Math.cos(t),\n        r = Math.sin(t),\n        i = e * this.x - r * this.y,\n        n = r * this.x + e * this.y;\n    return this.x = i, this.y = n, this;\n  },\n  _round: function () {\n    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;\n  }\n}, Point$1.convert = function (t) {\n  return t instanceof Point$1 ? t : Array.isArray(t) ? new Point$1(t[0], t[1]) : t;\n};\nvar Point = index$5,\n    vectortilefeature = VectorTileFeature$2;\nVectorTileFeature$2.types = [\"Unknown\", \"Point\", \"LineString\", \"Polygon\"], VectorTileFeature$2.prototype.loadGeometry = function () {\n  var t = this._pbf;\n  t.pos = this._geometry;\n\n  for (var e, r = t.readVarint() + t.pos, i = 1, n = 0, o = 0, s = 0, a = []; t.pos < r;) {\n    if (!n) {\n      var u = t.readVarint();\n      i = 7 & u, n = u >> 3;\n    }\n\n    if (n--, 1 === i || 2 === i) o += t.readSVarint(), s += t.readSVarint(), 1 === i && (e && a.push(e), e = []), e.push(new Point(o, s));else {\n      if (7 !== i) throw new Error(\"unknown command \" + i);\n      e && e.push(e[0].clone());\n    }\n  }\n\n  return e && a.push(e), a;\n}, VectorTileFeature$2.prototype.bbox = function () {\n  var t = this._pbf;\n  t.pos = this._geometry;\n\n  for (var e = t.readVarint() + t.pos, r = 1, i = 0, n = 0, o = 0, s = 1 / 0, a = -1 / 0, u = 1 / 0, h = -1 / 0; t.pos < e;) {\n    if (!i) {\n      var l = t.readVarint();\n      r = 7 & l, i = l >> 3;\n    }\n\n    if (i--, 1 === r || 2 === r) n += t.readSVarint(), o += t.readSVarint(), n < s && (s = n), n > a && (a = n), o < u && (u = o), o > h && (h = o);else if (7 !== r) throw new Error(\"unknown command \" + r);\n  }\n\n  return [s, u, a, h];\n}, VectorTileFeature$2.prototype.toGeoJSON = function (t, e, r) {\n  function i(t) {\n    for (var e = 0; e < t.length; e++) {\n      var r = t[e],\n          i = 180 - 360 * (r.y + u) / s;\n      t[e] = [360 * (r.x + a) / s - 180, 360 / Math.PI * Math.atan(Math.exp(i * Math.PI / 180)) - 90];\n    }\n  }\n\n  var n,\n      o,\n      s = this.extent * Math.pow(2, r),\n      a = this.extent * t,\n      u = this.extent * e,\n      h = this.loadGeometry(),\n      l = VectorTileFeature$2.types[this.type];\n\n  switch (this.type) {\n    case 1:\n      var c = [];\n\n      for (n = 0; n < h.length; n++) c[n] = h[n][0];\n\n      h = c, i(h);\n      break;\n\n    case 2:\n      for (n = 0; n < h.length; n++) i(h[n]);\n\n      break;\n\n    case 3:\n      for (h = classifyRings(h), n = 0; n < h.length; n++) for (o = 0; o < h[n].length; o++) i(h[n][o]);\n\n  }\n\n  1 === h.length ? h = h[0] : l = \"Multi\" + l;\n  var f = {\n    type: \"Feature\",\n    geometry: {\n      type: l,\n      coordinates: h\n    },\n    properties: this.properties\n  };\n  return \"id\" in this && (f.id = this.id), f;\n};\nvar VectorTileFeature$1 = vectortilefeature,\n    vectortilelayer = VectorTileLayer$2;\n\nVectorTileLayer$2.prototype.feature = function (t) {\n  if (t < 0 || t >= this._features.length) throw new Error(\"feature index out of bounds\");\n  this._pbf.pos = this._features[t];\n\n  var e = this._pbf.readVarint() + this._pbf.pos;\n\n  return new VectorTileFeature$1(this._pbf, e, this.extent, this._keys, this._values);\n};\n\nvar VectorTileLayer$1 = vectortilelayer,\n    vectortile = VectorTile$1,\n    VectorTile = vectortile;\nL.SVG.Tile = L.SVG.extend({\n  initialize: function (t, e, r) {\n    L.SVG.prototype.initialize.call(this, r), this._tileCoord = t, this._size = e, this._initContainer(), this._container.setAttribute(\"width\", this._size.x), this._container.setAttribute(\"height\", this._size.y), this._container.setAttribute(\"viewBox\", [0, 0, this._size.x, this._size.y].join(\" \")), this._layers = {};\n  },\n  getCoord: function () {\n    return this._tileCoord;\n  },\n  getContainer: function () {\n    return this._container;\n  },\n  onAdd: L.Util.falseFn,\n  addTo: function (t) {\n    if (this._map = t, this.options.interactive) for (var e in this._layers) {\n      var r = this._layers[e];\n      r._path.style.pointerEvents = \"auto\", this._map._targets[L.stamp(r._path)] = r;\n    }\n  },\n  removeFrom: function (t) {\n    if (this.options.interactive) for (var e in this._layers) {\n      var r = this._layers[e];\n      delete this._map._targets[L.stamp(r._path)];\n    }\n    delete this._map;\n  },\n  _initContainer: function () {\n    L.SVG.prototype._initContainer.call(this);\n\n    L.SVG.create(\"rect\");\n  },\n  _addPath: function (t) {\n    this._rootGroup.appendChild(t._path), this._layers[L.stamp(t)] = t;\n  },\n  _updateIcon: function (t) {\n    var e = t._path = L.SVG.create(\"image\"),\n        r = t.options.icon,\n        i = r.options,\n        n = L.point(i.iconSize),\n        o = i.iconAnchor || n && n.divideBy(2, !0),\n        s = t._point.subtract(o);\n\n    e.setAttribute(\"x\", s.x), e.setAttribute(\"y\", s.y), e.setAttribute(\"width\", n.x + \"px\"), e.setAttribute(\"height\", n.y + \"px\"), e.setAttribute(\"href\", i.iconUrl);\n  }\n}), L.svg.tile = function (t, e, r) {\n  return new L.SVG.Tile(t, e, r);\n};\nvar Symbolizer = L.Class.extend({\n  render: function (t, e) {\n    this._renderer = t, this.options = e, t._initPath(this), t._updateStyle(this);\n  },\n  updateStyle: function (t, e) {\n    this.options = e, t._updateStyle(this);\n  },\n  _getPixelBounds: function () {\n    for (var t = this._parts, e = L.bounds([]), r = 0; r < t.length; r++) for (var i = t[r], n = 0; n < i.length; n++) e.extend(i[n]);\n\n    var o = this._clickTolerance(),\n        s = new L.Point(o, o);\n\n    return e.min._subtract(s), e.max._add(s), e;\n  },\n  _clickTolerance: L.Path.prototype._clickTolerance\n}),\n    PolyBase = {\n  _makeFeatureParts: function (t, e) {\n    var r,\n        i = t.geometry;\n    this._parts = [];\n\n    for (var n = 0; n < i.length; n++) {\n      for (var o = i[n], s = [], a = 0; a < o.length; a++) r = o[a], s.push(L.point(r).scaleBy(e));\n\n      this._parts.push(s);\n    }\n  },\n  makeInteractive: function () {\n    this._pxBounds = this._getPixelBounds();\n  }\n},\n    PointSymbolizer = L.CircleMarker.extend({\n  includes: Symbolizer.prototype,\n  statics: {\n    iconCache: {}\n  },\n  initialize: function (t, e) {\n    this.properties = t.properties, this._makeFeatureParts(t, e);\n  },\n  render: function (t, e) {\n    Symbolizer.prototype.render.call(this, t, e), this._radius = e.radius || L.CircleMarker.prototype.options.radius, this._updatePath();\n  },\n  _makeFeatureParts: function (t, e) {\n    var r = t.geometry[0];\n    \"object\" == typeof r[0] && \"x\" in r[0] ? (this._point = L.point(r[0]).scaleBy(e), this._empty = L.Util.falseFn) : (this._point = L.point(r).scaleBy(e), this._empty = L.Util.falseFn);\n  },\n  makeInteractive: function () {\n    this._updateBounds();\n  },\n  updateStyle: function (t, e) {\n    return this._radius = e.radius || this._radius, this._updateBounds(), Symbolizer.prototype.updateStyle.call(this, t, e);\n  },\n  _updateBounds: function () {\n    var t = this.options.icon;\n\n    if (t) {\n      var e = L.point(t.options.iconSize),\n          r = t.options.iconAnchor || e && e.divideBy(2, !0),\n          i = this._point.subtract(r);\n\n      this._pxBounds = new L.Bounds(i, i.add(t.options.iconSize));\n    } else L.CircleMarker.prototype._updateBounds.call(this);\n  },\n  _updatePath: function () {\n    this.options.icon ? this._renderer._updateIcon(this) : L.CircleMarker.prototype._updatePath.call(this);\n  },\n  _getImage: function () {\n    if (this.options.icon) {\n      var t = this.options.icon.options.iconUrl,\n          e = PointSymbolizer.iconCache[t];\n\n      if (!e) {\n        var r = this.options.icon;\n        e = PointSymbolizer.iconCache[t] = r.createIcon();\n      }\n\n      return e;\n    }\n\n    return null;\n  },\n  _containsPoint: function (t) {\n    return this.options.icon ? this._pxBounds.contains(t) : L.CircleMarker.prototype._containsPoint.call(this, t);\n  }\n}),\n    LineSymbolizer = L.Polyline.extend({\n  includes: [Symbolizer.prototype, PolyBase],\n  initialize: function (t, e) {\n    this.properties = t.properties, this._makeFeatureParts(t, e);\n  },\n  render: function (t, e) {\n    e.fill = !1, Symbolizer.prototype.render.call(this, t, e), this._updatePath();\n  },\n  updateStyle: function (t, e) {\n    e.fill = !1, Symbolizer.prototype.updateStyle.call(this, t, e);\n  }\n}),\n    FillSymbolizer = L.Polygon.extend({\n  includes: [Symbolizer.prototype, PolyBase],\n  initialize: function (t, e) {\n    this.properties = t.properties, this._makeFeatureParts(t, e);\n  },\n  render: function (t, e) {\n    Symbolizer.prototype.render.call(this, t, e), this._updatePath();\n  }\n});\nL.VectorGrid = L.GridLayer.extend({\n  options: {\n    rendererFactory: L.svg.tile,\n    vectorTileLayerStyles: {},\n    interactive: !1\n  },\n  initialize: function (t) {\n    L.setOptions(this, t), L.GridLayer.prototype.initialize.apply(this, arguments), this.options.getFeatureId && (this._vectorTiles = {}, this._overriddenStyles = {}, this.on(\"tileunload\", function (t) {\n      var e = this._tileCoordsToKey(t.coords),\n          r = this._vectorTiles[e];\n\n      r && this._map && r.removeFrom(this._map), delete this._vectorTiles[e];\n    }, this)), this._dataLayerNames = {};\n  },\n  createTile: function (t, e) {\n    var r = this.options.getFeatureId,\n        i = this.getTileSize(),\n        n = this.options.rendererFactory(t, i, this.options),\n        o = this._tileCoordsToBounds(t),\n        s = this._getVectorTilePromise(t, o);\n\n    return r && (this._vectorTiles[this._tileCoordsToKey(t)] = n, n._features = {}), s.then(function (i) {\n      if (i.layers && 0 !== i.layers.length) for (var o in i.layers) {\n        this._dataLayerNames[o] = !0;\n\n        for (var s = i.layers[o], a = this.getTileSize().divideBy(s.extent), u = this.options.vectorTileLayerStyles[o] || L.Path.prototype.options, h = 0; h < s.features.length; h++) {\n          var l,\n              c = s.features[h],\n              f = u;\n\n          if (r) {\n            l = this.options.getFeatureId(c);\n            var p = this._overriddenStyles[l];\n            p && (f = p[o] ? p[o] : p);\n          }\n\n          if (f instanceof Function && (f = f(c.properties, t.z)), f instanceof Array || (f = [f]), f.length) {\n            for (var d = this._createLayer(c, a), y = 0; y < f.length; y++) {\n              var m = L.extend({}, L.Path.prototype.options, f[y]);\n              d.render(n, m), n._addPath(d);\n            }\n\n            this.options.interactive && d.makeInteractive(), r && (n._features[l] = {\n              layerName: o,\n              feature: d\n            });\n          }\n        }\n      }\n      null != this._map && n.addTo(this._map), L.Util.requestAnimFrame(e.bind(t, null, null));\n    }.bind(this)), n.getContainer();\n  },\n  setFeatureStyle: function (t, e) {\n    this._overriddenStyles[t] = e;\n\n    for (var r in this._vectorTiles) {\n      var i = this._vectorTiles[r],\n          n = i._features,\n          o = n[t];\n\n      if (o) {\n        var s = o.feature,\n            a = e;\n        e[o.layerName] && (a = e[o.layerName]), this._updateStyles(s, i, a);\n      }\n    }\n\n    return this;\n  },\n  resetFeatureStyle: function (t) {\n    delete this._overriddenStyles[t];\n\n    for (var e in this._vectorTiles) {\n      var r = this._vectorTiles[e],\n          i = r._features,\n          n = i[t];\n\n      if (n) {\n        var o = n.feature,\n            s = this.options.vectorTileLayerStyles[n.layerName] || L.Path.prototype.options;\n\n        this._updateStyles(o, r, s);\n      }\n    }\n\n    return this;\n  },\n  getDataLayerNames: function () {\n    return Object.keys(this._dataLayerNames);\n  },\n  _updateStyles: function (t, e, r) {\n    (r = r instanceof Function ? r(t.properties, e.getCoord().z) : r) instanceof Array || (r = [r]);\n\n    for (var i = 0; i < r.length; i++) {\n      var n = L.extend({}, L.Path.prototype.options, r[i]);\n      t.updateStyle(e, n);\n    }\n  },\n  _createLayer: function (t, e, r) {\n    var i;\n\n    switch (t.type) {\n      case 1:\n        i = new PointSymbolizer(t, e), i.getLatLng = null;\n        break;\n\n      case 2:\n        i = new LineSymbolizer(t, e);\n        break;\n\n      case 3:\n        i = new FillSymbolizer(t, e);\n    }\n\n    return this.options.interactive && i.addEventParent(this), i;\n  }\n}), L.vectorGrid = function (t) {\n  return new L.VectorGrid(t);\n}, L.VectorGrid.Protobuf = L.VectorGrid.extend({\n  options: {\n    subdomains: \"abc\",\n    fetchOptions: {}\n  },\n  initialize: function (t, e) {\n    this._url = t, L.VectorGrid.prototype.initialize.call(this, e);\n  },\n  setUrl: function (t, e) {\n    return this._url = t, e || this.redraw(), this;\n  },\n  _getSubdomain: L.TileLayer.prototype._getSubdomain,\n  _isCurrentTile: function (t, e) {\n    if (!this._map) return !0;\n\n    var r = this._map._animateToZoom || this._map._zoom,\n        i = r === t.z,\n        e = this._tileCoordsToBounds(t),\n        n = this._map.getBounds().overlaps(e);\n\n    return i && n;\n  },\n  _getVectorTilePromise: function (t, e) {\n    var r = {\n      s: this._getSubdomain(t),\n      x: t.x,\n      y: t.y,\n      z: t.z\n    };\n\n    if (this._map && !this._map.options.crs.infinite) {\n      var i = this._globalTileRange.max.y - t.y;\n      this.options.tms && (r.y = i), r[\"-y\"] = i;\n    }\n\n    if (!this._isCurrentTile(t, e)) return Promise.resolve({\n      layers: []\n    });\n    var n = L.Util.template(this._url, L.extend(r, this.options));\n    return fetch(n, this.options.fetchOptions).then(function (e) {\n      return e.ok && this._isCurrentTile(t) ? e.blob().then(function (t) {\n        var e = new FileReader();\n        return new Promise(function (r) {\n          e.addEventListener(\"loadend\", function () {\n            var t = new index(e.result);\n            return r(new VectorTile(t));\n          }), e.readAsArrayBuffer(t);\n        });\n      }) : {\n        layers: []\n      };\n    }.bind(this)).then(function (t) {\n      for (var e in t.layers) {\n        for (var r = [], i = 0; i < t.layers[e].length; i++) {\n          var n = t.layers[e].feature(i);\n          n.geometry = n.loadGeometry(), r.push(n);\n        }\n\n        t.layers[e].features = r;\n      }\n\n      return t;\n    });\n  }\n}), L.vectorGrid.protobuf = function (t, e) {\n  return new L.VectorGrid.Protobuf(t, e);\n};\n\nvar workerCode = __$strToBlobUri('\"use strict\";function simplify$1(e,t){var r,n,o,i,a=t*t,s=e.length,l=0,u=s-1,c=[];for(e[l][2]=1,e[u][2]=1;u;){for(n=0,r=l+1;r<u;r++)(o=getSqSegDist(e[r],e[l],e[u]))>n&&(i=r,n=o);n>a?(e[i][2]=n,c.push(l),c.push(i),l=i):(u=c.pop(),l=c.pop())}}function getSqSegDist(e,t,r){var n=t[0],o=t[1],i=r[0],a=r[1],s=e[0],l=e[1],u=i-n,c=a-o;if(0!==u||0!==c){var f=((s-n)*u+(l-o)*c)/(u*u+c*c);f>1?(n=i,o=a):f>0&&(n+=u*f,o+=c*f)}return u=s-n,c=l-o,u*u+c*c}function convert$1(e,t){var r=[];if(\"FeatureCollection\"===e.type)for(var n=0;n<e.features.length;n++)convertFeature(r,e.features[n],t);else\"Feature\"===e.type?convertFeature(r,e,t):convertFeature(r,{geometry:e},t);return r}function convertFeature(e,t,r){if(null!==t.geometry){var n,o,i,a,s=t.geometry,l=s.type,u=s.coordinates,c=t.properties;if(\"Point\"===l)e.push(create(c,1,[projectPoint(u)]));else if(\"MultiPoint\"===l)e.push(create(c,1,project(u)));else if(\"LineString\"===l)e.push(create(c,2,[project(u,r)]));else if(\"MultiLineString\"===l||\"Polygon\"===l){for(i=[],n=0;n<u.length;n++)a=project(u[n],r),\"Polygon\"===l&&(a.outer=0===n),i.push(a);e.push(create(c,\"Polygon\"===l?3:2,i))}else if(\"MultiPolygon\"===l){for(i=[],n=0;n<u.length;n++)for(o=0;o<u[n].length;o++)a=project(u[n][o],r),a.outer=0===o,i.push(a);e.push(create(c,3,i))}else{if(\"GeometryCollection\"!==l)throw new Error(\"Input data is not a valid GeoJSON object.\");for(n=0;n<s.geometries.length;n++)convertFeature(e,{geometry:s.geometries[n],properties:c},r)}}}function create(e,t,r){var n={geometry:r,type:t,tags:e||null,min:[2,1],max:[-1,0]};return calcBBox(n),n}function project(e,t){for(var r=[],n=0;n<e.length;n++)r.push(projectPoint(e[n]));return t&&(simplify(r,t),calcSize(r)),r}function projectPoint(e){var t=Math.sin(e[1]*Math.PI/180),r=e[0]/360+.5,n=.5-.25*Math.log((1+t)/(1-t))/Math.PI;return n=n<0?0:n>1?1:n,[r,n,0]}function calcSize(e){for(var t,r,n=0,o=0,i=0;i<e.length-1;i++)t=r||e[i],r=e[i+1],n+=t[0]*r[1]-r[0]*t[1],o+=Math.abs(r[0]-t[0])+Math.abs(r[1]-t[1]);e.area=Math.abs(n/2),e.dist=o}function calcBBox(e){var t=e.geometry,r=e.min,n=e.max;if(1===e.type)calcRingBBox(r,n,t);else for(var o=0;o<t.length;o++)calcRingBBox(r,n,t[o]);return e}function calcRingBBox(e,t,r){for(var n,o=0;o<r.length;o++)n=r[o],e[0]=Math.min(n[0],e[0]),t[0]=Math.max(n[0],t[0]),e[1]=Math.min(n[1],e[1]),t[1]=Math.max(n[1],t[1])}function transformTile(e,t){if(e.transformed)return e;var r,n,o,i=e.z2,a=e.x,s=e.y;for(r=0;r<e.features.length;r++){var l=e.features[r],u=l.geometry;if(1===l.type)for(n=0;n<u.length;n++)u[n]=transformPoint(u[n],t,i,a,s);else for(n=0;n<u.length;n++){var c=u[n];for(o=0;o<c.length;o++)c[o]=transformPoint(c[o],t,i,a,s)}}return e.transformed=!0,e}function transformPoint(e,t,r,n,o){return[Math.round(t*(e[0]*r-n)),Math.round(t*(e[1]*r-o))]}function clip$1(e,t,r,n,o,i,a,s){if(r/=t,n/=t,a>=r&&s<=n)return e;if(a>n||s<r)return null;for(var l=[],u=0;u<e.length;u++){var c,f,p=e[u],h=p.geometry,m=p.type;if(c=p.min[o],f=p.max[o],c>=r&&f<=n)l.push(p);else if(!(c>n||f<r)){var g=1===m?clipPoints(h,r,n,o):clipGeometry(h,r,n,o,i,3===m);g.length&&l.push({geometry:g,type:m,tags:e[u].tags||null,min:p.min,max:p.max})}}return l.length?l:null}function clipPoints(e,t,r,n){for(var o=[],i=0;i<e.length;i++){var a=e[i],s=a[n];s>=t&&s<=r&&o.push(a)}return o}function clipGeometry(e,t,r,n,o,i){for(var a=[],s=0;s<e.length;s++){var l,u,c,f=0,p=0,h=null,m=e[s],g=m.area,d=m.dist,v=m.outer,y=m.length,x=[];for(u=0;u<y-1;u++)l=h||m[u],h=m[u+1],f=p||l[n],p=h[n],f<t?p>r?(x.push(o(l,h,t),o(l,h,r)),i||(x=newSlice(a,x,g,d,v))):p>=t&&x.push(o(l,h,t)):f>r?p<t?(x.push(o(l,h,r),o(l,h,t)),i||(x=newSlice(a,x,g,d,v))):p<=r&&x.push(o(l,h,r)):(x.push(l),p<t?(x.push(o(l,h,t)),i||(x=newSlice(a,x,g,d,v))):p>r&&(x.push(o(l,h,r)),i||(x=newSlice(a,x,g,d,v))));l=m[y-1],f=l[n],f>=t&&f<=r&&x.push(l),c=x[x.length-1],i&&c&&(x[0][0]!==c[0]||x[0][1]!==c[1])&&x.push(x[0]),newSlice(a,x,g,d,v)}return a}function newSlice(e,t,r,n,o){return t.length&&(t.area=r,t.dist=n,void 0!==o&&(t.outer=o),e.push(t)),[]}function wrap$1(e,t,r){var n=e,o=clip$2(e,1,-1-t,t,0,r,-1,2),i=clip$2(e,1,1-t,2+t,0,r,-1,2);return(o||i)&&(n=clip$2(e,1,-t,1+t,0,r,-1,2),o&&(n=shiftFeatureCoords(o,1).concat(n)),i&&(n=n.concat(shiftFeatureCoords(i,-1)))),n}function shiftFeatureCoords(e,t){for(var r=[],n=0;n<e.length;n++){var o,i=e[n],a=i.type;if(1===a)o=shiftCoords(i.geometry,t);else{o=[];for(var s=0;s<i.geometry.length;s++)o.push(shiftCoords(i.geometry[s],t))}r.push({geometry:o,type:a,tags:i.tags,min:[i.min[0]+t,i.min[1]],max:[i.max[0]+t,i.max[1]]})}return r}function shiftCoords(e,t){var r=[];r.area=e.area,r.dist=e.dist;for(var n=0;n<e.length;n++)r.push([e[n][0]+t,e[n][1],e[n][2]]);return r}function createTile$1(e,t,r,n,o,i){for(var a={features:[],numPoints:0,numSimplified:0,numFeatures:0,source:null,x:r,y:n,z2:t,transformed:!1,min:[2,1],max:[-1,0]},s=0;s<e.length;s++){a.numFeatures++,addFeature(a,e[s],o,i);var l=e[s].min,u=e[s].max;l[0]<a.min[0]&&(a.min[0]=l[0]),l[1]<a.min[1]&&(a.min[1]=l[1]),u[0]>a.max[0]&&(a.max[0]=u[0]),u[1]>a.max[1]&&(a.max[1]=u[1])}return a}function addFeature(e,t,r,n){var o,i,a,s,l=t.geometry,u=t.type,c=[],f=r*r;if(1===u)for(o=0;o<l.length;o++)c.push(l[o]),e.numPoints++,e.numSimplified++;else for(o=0;o<l.length;o++)if(a=l[o],n||!(2===u&&a.dist<r||3===u&&a.area<f)){var p=[];for(i=0;i<a.length;i++)s=a[i],(n||s[2]>f)&&(p.push(s),e.numSimplified++),e.numPoints++;3===u&&rewind(p,a.outer),c.push(p)}else e.numPoints+=a.length;c.length&&e.features.push({geometry:c,type:u,tags:t.tags||null})}function rewind(e,t){signedArea(e)<0===t&&e.reverse()}function signedArea(e){for(var t,r,n=0,o=0,i=e.length,a=i-1;o<i;a=o++)t=e[o],r=e[a],n+=(r[0]-t[0])*(t[1]+r[1]);return n}function geojsonvt(e,t){return new GeoJSONVT(e,t)}function GeoJSONVT(e,t){t=this.options=extend(Object.create(this.options),t);var r=t.debug;r&&console.time(\"preprocess data\");var n=1<<t.maxZoom,o=convert(e,t.tolerance/(n*t.extent));this.tiles={},this.tileCoords=[],r&&(console.timeEnd(\"preprocess data\"),console.log(\"index: maxZoom: %d, maxPoints: %d\",t.indexMaxZoom,t.indexMaxPoints),console.time(\"generate tiles\"),this.stats={},this.total=0),o=wrap(o,t.buffer/t.extent,intersectX),o.length&&this.splitTile(o,0,0,0),r&&(o.length&&console.log(\"features: %d, points: %d\",this.tiles[0].numFeatures,this.tiles[0].numPoints),console.timeEnd(\"generate tiles\"),console.log(\"tiles generated:\",this.total,JSON.stringify(this.stats)))}function toID(e,t,r){return 32*((1<<e)*r+t)+e}function intersectX(e,t,r){return[r,(r-e[0])*(t[1]-e[1])/(t[0]-e[0])+e[1],1]}function intersectY(e,t,r){return[(r-e[1])*(t[0]-e[0])/(t[1]-e[1])+e[0],r,1]}function extend(e,t){for(var r in t)e[r]=t[r];return e}function isClippedSquare(e,t,r){var n=e.source;if(1!==n.length)return!1;var o=n[0];if(3!==o.type||o.geometry.length>1)return!1;var i=o.geometry[0].length;if(5!==i)return!1;for(var a=0;a<i;a++){var s=transform.point(o.geometry[0][a],t,e.z2,e.x,e.y);if(s[0]!==-r&&s[0]!==t+r||s[1]!==-r&&s[1]!==t+r)return!1}return!0}function feature$1(e,t){var r=t.id,n=t.bbox,o=null==t.properties?{}:t.properties,i=object(e,t);return null==r&&null==n?{type:\"Feature\",properties:o,geometry:i}:null==n?{type:\"Feature\",id:r,properties:o,geometry:i}:{type:\"Feature\",id:r,bbox:n,properties:o,geometry:i}}function object(e,t){function r(e,t){t.length&&t.pop();for(var r=u[e<0?~e:e],n=0,o=r.length;n<o;++n)t.push(l(r[n].slice(),n));e<0&&reverse(t,o)}function n(e){return l(e.slice())}function o(e){for(var t=[],n=0,o=e.length;n<o;++n)r(e[n],t);return t.length<2&&t.push(t[0].slice()),t}function i(e){for(var t=o(e);t.length<4;)t.push(t[0].slice());return t}function a(e){return e.map(i)}function s(e){var t,r=e.type;switch(r){case\"GeometryCollection\":return{type:r,geometries:e.geometries.map(s)};case\"Point\":t=n(e.coordinates);break;case\"MultiPoint\":t=e.coordinates.map(n);break;case\"LineString\":t=o(e.arcs);break;case\"MultiLineString\":t=e.arcs.map(o);break;case\"Polygon\":t=a(e.arcs);break;case\"MultiPolygon\":t=e.arcs.map(a);break;default:return null}return{type:r,coordinates:t}}var l=transform$3(e),u=e.arcs;return s(t)}function extractArcs(e,t,r){function n(e){var t=e<0?~e:e;(c[t]||(c[t]=[])).push({i:e,g:l})}function o(e){e.forEach(n)}function i(e){e.forEach(o)}function a(e){e.forEach(i)}function s(e){switch(l=e,e.type){case\"GeometryCollection\":e.geometries.forEach(s);break;case\"LineString\":o(e.arcs);break;case\"MultiLineString\":case\"Polygon\":i(e.arcs);break;case\"MultiPolygon\":a(e.arcs)}}var l,u=[],c=[];return s(t),c.forEach(null==r?function(e){u.push(e[0].i)}:function(e){r(e[0].g,e[e.length-1].g)&&u.push(e[0].i)}),u}function planarRingArea(e){for(var t,r=-1,n=e.length,o=e[n-1],i=0;++r<n;)t=o,o=e[r],i+=t[0]*o[1]-t[1]*o[0];return Math.abs(i)}var simplify_1=simplify$1,convert_1=convert$1,simplify=simplify_1,tile=transformTile,point=transformPoint,transform$1={tile:tile,point:point},clip_1=clip$1,clip$2=clip_1,wrap_1=wrap$1,tile$1=createTile$1,index=geojsonvt,convert=convert_1,transform=transform$1,clip=clip_1,wrap=wrap_1,createTile=tile$1;GeoJSONVT.prototype.options={maxZoom:14,indexMaxZoom:5,indexMaxPoints:1e5,solidChildren:!1,tolerance:3,extent:4096,buffer:64,debug:0},GeoJSONVT.prototype.splitTile=function(e,t,r,n,o,i,a){for(var s=this,l=[e,t,r,n],u=this.options,c=u.debug,f=null;l.length;){n=l.pop(),r=l.pop(),t=l.pop(),e=l.pop();var p=1<<t,h=toID(t,r,n),m=s.tiles[h],g=t===u.maxZoom?0:u.tolerance/(p*u.extent);if(!m&&(c>1&&console.time(\"creation\"),m=s.tiles[h]=createTile(e,p,r,n,g,t===u.maxZoom),s.tileCoords.push({z:t,x:r,y:n}),c)){c>1&&(console.log(\"tile z%d-%d-%d (features: %d, points: %d, simplified: %d)\",t,r,n,m.numFeatures,m.numPoints,m.numSimplified),console.timeEnd(\"creation\"));var d=\"z\"+t;s.stats[d]=(s.stats[d]||0)+1,s.total++}if(m.source=e,o){if(t===u.maxZoom||t===o)continue;var v=1<<o-t;if(r!==Math.floor(i/v)||n!==Math.floor(a/v))continue}else if(t===u.indexMaxZoom||m.numPoints<=u.indexMaxPoints)continue;if(u.solidChildren||!isClippedSquare(m,u.extent,u.buffer)){m.source=null,c>1&&console.time(\"clipping\");var y,x,b,M,P,S,w=.5*u.buffer/u.extent,$=.5-w,C=.5+w,F=1+w;y=x=b=M=null,P=clip(e,p,r-w,r+C,0,intersectX,m.min[0],m.max[0]),S=clip(e,p,r+$,r+F,0,intersectX,m.min[0],m.max[0]),P&&(y=clip(P,p,n-w,n+C,1,intersectY,m.min[1],m.max[1]),x=clip(P,p,n+$,n+F,1,intersectY,m.min[1],m.max[1])),S&&(b=clip(S,p,n-w,n+C,1,intersectY,m.min[1],m.max[1]),M=clip(S,p,n+$,n+F,1,intersectY,m.min[1],m.max[1])),c>1&&console.timeEnd(\"clipping\"),y&&l.push(y,t+1,2*r,2*n),x&&l.push(x,t+1,2*r,2*n+1),b&&l.push(b,t+1,2*r+1,2*n),M&&l.push(M,t+1,2*r+1,2*n+1)}else o&&(f=t)}return f},GeoJSONVT.prototype.getTile=function(e,t,r){var n=this,o=this.options,i=o.extent,a=o.debug,s=1<<e;t=(t%s+s)%s;var l=toID(e,t,r);if(this.tiles[l])return transform.tile(this.tiles[l],i);a>1&&console.log(\"drilling down to z%d-%d-%d\",e,t,r);for(var u,c=e,f=t,p=r;!u&&c>0;)c--,f=Math.floor(f/2),p=Math.floor(p/2),u=n.tiles[toID(c,f,p)];if(!u||!u.source)return null;if(a>1&&console.log(\"found parent tile z%d-%d-%d\",c,f,p),isClippedSquare(u,i,o.buffer))return transform.tile(u,i);a>1&&console.time(\"drilling down\");var h=this.splitTile(u.source,c,f,p,e,t,r);if(a>1&&console.timeEnd(\"drilling down\"),null!==h){var m=1<<e-h;l=toID(h,Math.floor(t/m),Math.floor(r/m))}return this.tiles[l]?transform.tile(this.tiles[l],i):null};var identity=function(e){return e},transform$3=function(e){if(null==(t=e.transform))return identity;var t,r,n,o=t.scale[0],i=t.scale[1],a=t.translate[0],s=t.translate[1];return function(e,t){return t||(r=n=0),e[0]=(r+=e[0])*o+a,e[1]=(n+=e[1])*i+s,e}},bbox=function(e){function t(e){s[0]=e[0],s[1]=e[1],a(s),s[0]<l&&(l=s[0]),s[0]>c&&(c=s[0]),s[1]<u&&(u=s[1]),s[1]>f&&(f=s[1])}function r(e){switch(e.type){case\"GeometryCollection\":e.geometries.forEach(r);break;case\"Point\":t(e.coordinates);break;case\"MultiPoint\":e.coordinates.forEach(t)}}var n=e.bbox;if(!n){var o,i,a=transform$3(e),s=new Array(2),l=1/0,u=l,c=-l,f=-l;e.arcs.forEach(function(e){for(var t=-1,r=e.length;++t<r;)o=e[t],s[0]=o[0],s[1]=o[1],a(s,t),s[0]<l&&(l=s[0]),s[0]>c&&(c=s[0]),s[1]<u&&(u=s[1]),s[1]>f&&(f=s[1])});for(i in e.objects)r(e.objects[i]);n=e.bbox=[l,u,c,f]}return n},reverse=function(e,t){for(var r,n=e.length,o=n-t;o<--n;)r=e[o],e[o++]=e[n],e[n]=r},feature=function(e,t){return\"GeometryCollection\"===t.type?{type:\"FeatureCollection\",features:t.geometries.map(function(t){return feature$1(e,t)})}:feature$1(e,t)},stitch=function(e,t){function r(t){var r,n=e.arcs[t<0?~t:t],o=n[0];return e.transform?(r=[0,0],n.forEach(function(e){r[0]+=e[0],r[1]+=e[1]})):r=n[n.length-1],t<0?[r,o]:[o,r]}function n(e,t){for(var r in e){var n=e[r];delete t[n.start],delete n.start,delete n.end,n.forEach(function(e){o[e<0?~e:e]=1}),s.push(n)}}var o={},i={},a={},s=[],l=-1;return t.forEach(function(r,n){var o,i=e.arcs[r<0?~r:r];i.length<3&&!i[1][0]&&!i[1][1]&&(o=t[++l],t[l]=r,t[n]=o)}),t.forEach(function(e){var t,n,o=r(e),s=o[0],l=o[1];if(t=a[s])if(delete a[t.end],t.push(e),t.end=l,n=i[l]){delete i[n.start];var u=n===t?t:t.concat(n);i[u.start=t.start]=a[u.end=n.end]=u}else i[t.start]=a[t.end]=t;else if(t=i[l])if(delete i[t.start],t.unshift(e),t.start=s,n=a[s]){delete a[n.end];var c=n===t?t:n.concat(t);i[c.start=n.start]=a[c.end=t.end]=c}else i[t.start]=a[t.end]=t;else t=[e],i[t.start=s]=a[t.end=l]=t}),n(a,i),n(i,a),t.forEach(function(e){o[e<0?~e:e]||s.push([e])}),s},bisect=function(e,t){for(var r=0,n=e.length;r<n;){var o=r+n>>>1;e[o]<t?r=o+1:n=o}return r},slicers={},options;onmessage=function(e){if(\"slice\"===e.data[0]){var t=e.data[1];if(options=e.data[2],t.type&&\"Topology\"===t.type)for(var r in t.objects)slicers[r]=index(feature(t,t.objects[r]),options);else slicers[options.vectorTileLayerName]=index(t,options)}else if(\"get\"===e.data[0]){var n=e.data[1],o={};for(var r in slicers){var i=slicers[r].getTile(n.z,n.x,n.y);if(i){var a={features:[],extent:options.extent,name:options.vectorTileLayerName,length:i.features.length};for(var s in i.features){var l={geometry:i.features[s].geometry,properties:i.features[s].tags,type:i.features[s].type};a.features.push(l)}o[r]=a}}postMessage({layers:o,coords:n})}};\\n', \"text/plain; charset=us-ascii\", !1);\n\nL.VectorGrid.Slicer = L.VectorGrid.extend({\n  options: {\n    vectorTileLayerName: \"sliced\",\n    extent: 4096,\n    maxZoom: 14\n  },\n  initialize: function (t, e) {\n    L.VectorGrid.prototype.initialize.call(this, e);\n    var e = {};\n\n    for (var r in this.options) \"rendererFactory\" !== r && \"vectorTileLayerStyles\" !== r && \"function\" != typeof this.options[r] && (e[r] = this.options[r]);\n\n    this._worker = new Worker(workerCode), this._worker.postMessage([\"slice\", t, e]);\n  },\n  _getVectorTilePromise: function (t) {\n    var e = this,\n        r = new Promise(function (r) {\n      e._worker.addEventListener(\"message\", function i(n) {\n        n.data.coords && n.data.coords.x === t.x && n.data.coords.y === t.y && n.data.coords.z === t.z && (r(n.data), e._worker.removeEventListener(\"message\", i));\n      });\n    });\n    return this._worker.postMessage([\"get\", t]), r;\n  }\n}), L.vectorGrid.slicer = function (t, e) {\n  return new L.VectorGrid.Slicer(t, e);\n}, L.Canvas.Tile = L.Canvas.extend({\n  initialize: function (t, e, r) {\n    L.Canvas.prototype.initialize.call(this, r), this._tileCoord = t, this._size = e, this._initContainer(), this._container.setAttribute(\"width\", this._size.x), this._container.setAttribute(\"height\", this._size.y), this._layers = {}, this._drawnLayers = {}, this._drawing = !0, r.interactive && (this._container.style.pointerEvents = \"auto\");\n  },\n  getCoord: function () {\n    return this._tileCoord;\n  },\n  getContainer: function () {\n    return this._container;\n  },\n  getOffset: function () {\n    return this._tileCoord.scaleBy(this._size).subtract(this._map.getPixelOrigin());\n  },\n  onAdd: L.Util.falseFn,\n  addTo: function (t) {\n    this._map = t;\n  },\n  removeFrom: function (t) {\n    delete this._map;\n  },\n  _onClick: function (t) {\n    var e,\n        r,\n        i = this._map.mouseEventToLayerPoint(t).subtract(this.getOffset());\n\n    for (var n in this._layers) e = this._layers[n], e.options.interactive && e._containsPoint(i) && !this._map._draggableMoved(e) && (r = e);\n\n    r && (L.DomEvent.fakeStop(t), this._fireEvent([r], t));\n  },\n  _onMouseMove: function (t) {\n    if (this._map && !this._map.dragging.moving() && !this._map._animatingZoom) {\n      var e = this._map.mouseEventToLayerPoint(t).subtract(this.getOffset());\n\n      this._handleMouseHover(t, e);\n    }\n  },\n  _updateIcon: function (t) {\n    if (this._drawing) {\n      var e = t.options.icon,\n          r = e.options,\n          i = L.point(r.iconSize),\n          n = r.iconAnchor || i && i.divideBy(2, !0),\n          o = t._point.subtract(n),\n          s = this._ctx,\n          a = t._getImage();\n\n      a.complete ? s.drawImage(a, o.x, o.y, i.x, i.y) : L.DomEvent.on(a, \"load\", function () {\n        s.drawImage(a, o.x, o.y, i.x, i.y);\n      }), this._drawnLayers[t._leaflet_id] = t;\n    }\n  }\n}), L.canvas.tile = function (t, e, r) {\n  return new L.Canvas.Tile(t, e, r);\n};","map":null,"metadata":{},"sourceType":"script"}