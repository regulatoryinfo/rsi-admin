{"ast":null,"code":"var L = require('leaflet');\n\nvar fetchJsonp = require('fetch-jsonp');\n\nvar bboxIntersect = require('bbox-intersect');\n/**\n * Converts tile xyz coordinates to Quadkey\n * @param {Number} x\n * @param {Number} y\n * @param {Number} z\n * @return {Number} Quadkey\n */\n\n\nfunction toQuadKey(x, y, z) {\n  var index = '';\n\n  for (var i = z; i > 0; i--) {\n    var b = 0;\n    var mask = 1 << i - 1;\n    if ((x & mask) !== 0) b++;\n    if ((y & mask) !== 0) b += 2;\n    index += b.toString();\n  }\n\n  return index;\n}\n/**\n * Converts Leaflet BBoxString to Bing BBox\n * @param {String} bboxString 'southwest_lng,southwest_lat,northeast_lng,northeast_lat'\n * @return {Array} [south_lat, west_lng, north_lat, east_lng]\n */\n\n\nfunction toBingBBox(bboxString) {\n  var bbox = bboxString.split(',');\n  return [bbox[1], bbox[0], bbox[3], bbox[2]];\n}\n\nvar VALID_IMAGERY_SETS = ['Aerial', 'AerialWithLabels', 'AerialWithLabelsOnDemand', 'Road', 'RoadOnDemand', 'CanvasLight', 'CanvasDark', 'CanvasGray', 'OrdnanceSurvey'];\nvar DYNAMIC_IMAGERY_SETS = ['AerialWithLabelsOnDemand', 'RoadOnDemand'];\n/**\n * Create a new Bing Maps layer.\n * @param {string|object} options Either a [Bing Maps Key](https://msdn.microsoft.com/en-us/library/ff428642.aspx) or an options object\n * @param {string} options.BingMapsKey A valid Bing Maps Key (required)\n * @param {string} [options.imagerySet=Aerial] Type of imagery, see https://msdn.microsoft.com/en-us/library/ff701716.aspx\n * @param {string} [options.culture='en-US'] Language for labels, see https://msdn.microsoft.com/en-us/library/hh441729.aspx\n * @return {L.TileLayer} A Leaflet TileLayer to add to your map\n *\n * Create a basic map\n * @example\n * var map = L.map('map').setView([51.505, -0.09], 13)\n * L.TileLayer.Bing(MyBingMapsKey).addTo(map)\n */\n\nL.TileLayer.Bing = L.TileLayer.extend({\n  options: {\n    bingMapsKey: null,\n    // Required\n    imagerySet: 'Aerial',\n    culture: 'en-US',\n    minZoom: 1,\n    minNativeZoom: 1,\n    maxNativeZoom: 19\n  },\n  statics: {\n    METADATA_URL: 'https://dev.virtualearth.net/REST/v1/Imagery/Metadata/{imagerySet}?key={bingMapsKey}&include=ImageryProviders&uriScheme=https&c={culture}',\n    POINT_METADATA_URL: 'https://dev.virtualearth.net/REST/v1/Imagery/Metadata/{imagerySet}/{lat},{lng}?zl={z}&key={bingMapsKey}&uriScheme=https&c={culture}'\n  },\n  initialize: function (options) {\n    if (typeof options === 'string') {\n      options = {\n        bingMapsKey: options\n      };\n    }\n\n    if (options && options.BingMapsKey) {\n      options.bingMapsKey = options.BingMapsKey;\n      console.warn('use options.bingMapsKey instead of options.BingMapsKey');\n    }\n\n    if (!options || !options.bingMapsKey) {\n      throw new Error('Must supply options.BingMapsKey');\n    }\n\n    options = L.setOptions(this, options);\n\n    if (VALID_IMAGERY_SETS.indexOf(options.imagerySet) < 0) {\n      throw new Error(\"'\" + options.imagerySet + \"' is an invalid imagerySet, see https://github.com/digidem/leaflet-bing-layer#parameters\");\n    }\n\n    if (options && options.style && DYNAMIC_IMAGERY_SETS.indexOf(options.imagerySet) < 0) {\n      console.warn('Dynamic styles will only work with these imagerySet choices: ' + DYNAMIC_IMAGERY_SETS.join(', '));\n    }\n\n    var metaDataUrl = L.Util.template(L.TileLayer.Bing.METADATA_URL, {\n      bingMapsKey: this.options.bingMapsKey,\n      imagerySet: this.options.imagerySet,\n      culture: this.options.culture\n    });\n    this._imageryProviders = [];\n    this._attributions = []; // Keep a reference to the promise so we can use it later\n\n    this._fetch = fetchJsonp(metaDataUrl, {\n      jsonpCallback: 'jsonp'\n    }).then(function (response) {\n      return response.json();\n    }).then(this._metaDataOnLoad.bind(this)).catch(console.error.bind(console)); // for https://github.com/Leaflet/Leaflet/issues/137\n\n    if (!L.Browser.android) {\n      this.on('tileunload', this._onTileRemove);\n    }\n  },\n  createTile: function (coords, done) {\n    var tile = document.createElement('img');\n    L.DomEvent.on(tile, 'load', L.bind(this._tileOnLoad, this, done, tile));\n    L.DomEvent.on(tile, 'error', L.bind(this._tileOnError, this, done, tile));\n\n    if (this.options.crossOrigin) {\n      tile.crossOrigin = '';\n    }\n    /*\n     Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons\n     http://www.w3.org/TR/WCAG20-TECHS/H67\n    */\n\n\n    tile.alt = ''; // Don't create closure if we don't have to\n\n    if (this._url) {\n      tile.src = this.getTileUrl(coords);\n    } else {\n      this._fetch.then(function () {\n        tile.src = this.getTileUrl(coords);\n      }.bind(this)).catch(function (e) {\n        console.error(e);\n        done(e);\n      });\n    }\n\n    return tile;\n  },\n  getTileUrl: function (coords) {\n    var quadkey = toQuadKey(coords.x, coords.y, coords.z);\n    var url = L.Util.template(this._url, {\n      quadkey: quadkey,\n      subdomain: this._getSubdomain(coords),\n      culture: this.options.culture\n    });\n\n    if (typeof this.options.style === 'string') {\n      url += '&st=' + this.options.style;\n    }\n\n    return url;\n  },\n  // Update the attribution control every time the map is moved\n  onAdd: function (map) {\n    map.on('moveend', this._updateAttribution, this);\n    L.TileLayer.prototype.onAdd.call(this, map);\n\n    this._attributions.forEach(function (attribution) {\n      map.attributionControl.addAttribution(attribution);\n    });\n  },\n  // Clean up events and remove attributions from attribution control\n  onRemove: function (map) {\n    map.off('moveend', this._updateAttribution, this);\n\n    this._attributions.forEach(function (attribution) {\n      map.attributionControl.removeAttribution(attribution);\n    });\n\n    L.TileLayer.prototype.onRemove.call(this, map);\n  },\n\n  /**\n   * Get the [Bing Imagery metadata](https://msdn.microsoft.com/en-us/library/ff701712.aspx)\n   * for a specific [`LatLng`](http://leafletjs.com/reference.html#latlng)\n   * and zoom level. If either `latlng` or `zoom` is omitted and the layer is attached\n   * to a map, the map center and current map zoom are used.\n   * @param {L.LatLng} latlng\n   * @param {Number} zoom\n   * @return {Promise} Resolves to the JSON metadata\n   */\n  getMetaData: function (latlng, zoom) {\n    if (!this._map && (!latlng || !zoom)) {\n      return Promise.reject(new Error('If layer is not attached to map, you must provide LatLng and zoom'));\n    }\n\n    latlng = latlng || this._map.getCenter();\n    zoom = zoom || this._map.getZoom();\n    var PointMetaDataUrl = L.Util.template(L.TileLayer.Bing.POINT_METADATA_URL, {\n      bingMapsKey: this.options.bingMapsKey,\n      imagerySet: this.options.imagerySet,\n      z: zoom,\n      lat: latlng.lat,\n      lng: latlng.lng\n    });\n    return fetchJsonp(PointMetaDataUrl, {\n      jsonpCallback: 'jsonp'\n    }).then(function (response) {\n      return response.json();\n    }).catch(console.error.bind(console));\n  },\n  _metaDataOnLoad: function (metaData) {\n    if (metaData.statusCode !== 200) {\n      throw new Error('Bing Imagery Metadata error: \\n' + JSON.stringify(metaData, null, '  '));\n    }\n\n    var resource = metaData.resourceSets[0].resources[0];\n    this._url = resource.imageUrl;\n    this._imageryProviders = resource.imageryProviders || [];\n    this.options.subdomains = resource.imageUrlSubdomains;\n\n    this._updateAttribution();\n\n    return Promise.resolve();\n  },\n\n  /**\n   * Update the attribution control of the map with the provider attributions\n   * within the current map bounds\n   */\n  _updateAttribution: function () {\n    var map = this._map;\n    if (!map || !map.attributionControl) return;\n    var zoom = map.getZoom();\n    var bbox = toBingBBox(map.getBounds().toBBoxString());\n\n    this._fetch.then(function () {\n      var newAttributions = this._getAttributions(bbox, zoom);\n\n      var prevAttributions = this._attributions; // Add any new provider attributions in the current area to the attribution control\n\n      newAttributions.forEach(function (attr) {\n        if (prevAttributions.indexOf(attr) > -1) return;\n        map.attributionControl.addAttribution(attr);\n      }); // Remove any attributions that are no longer in the current area from the attribution control\n\n      prevAttributions.filter(function (attr) {\n        if (newAttributions.indexOf(attr) > -1) return;\n        map.attributionControl.removeAttribution(attr);\n      });\n      this._attributions = newAttributions;\n    }.bind(this));\n  },\n\n  /**\n   * Returns an array of attributions for given bbox and zoom\n   * @private\n   * @param {Array} bbox [west, south, east, north]\n   * @param {Number} zoom\n   * @return {Array} Array of attribution strings for each provider\n   */\n  _getAttributions: function (bbox, zoom) {\n    return this._imageryProviders.reduce(function (attributions, provider) {\n      for (var i = 0; i < provider.coverageAreas.length; i++) {\n        if (bboxIntersect(bbox, provider.coverageAreas[i].bbox) && zoom >= provider.coverageAreas[i].zoomMin && zoom <= provider.coverageAreas[i].zoomMax) {\n          attributions.push(provider.attribution);\n          return attributions;\n        }\n      }\n\n      return attributions;\n    }, []);\n  }\n});\n\nL.tileLayer.bing = function (options) {\n  return new L.TileLayer.Bing(options);\n};\n\nmodule.exports = L.TileLayer.Bing;","map":null,"metadata":{},"sourceType":"script"}